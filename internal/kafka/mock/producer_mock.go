// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mock

import (
	kafkaModel "Homework-1/internal/model/kafka"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ProducerMock implements kafka.Producer
type ProducerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mProducerMockClose

	funcSendMessage          func(topic string, message kafkaModel.Message) (err error)
	inspectFuncSendMessage   func(topic string, message kafkaModel.Message)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mProducerMockSendMessage

	funcTopic          func() (s1 string)
	inspectFuncTopic   func()
	afterTopicCounter  uint64
	beforeTopicCounter uint64
	TopicMock          mProducerMockTopic
}

// NewProducerMock returns a mock for kafka.Producer
func NewProducerMock(t minimock.Tester) *ProducerMock {
	m := &ProducerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mProducerMockClose{mock: m}

	m.SendMessageMock = mProducerMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ProducerMockSendMessageParams{}

	m.TopicMock = mProducerMockTopic{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mProducerMockClose struct {
	mock               *ProducerMock
	defaultExpectation *ProducerMockCloseExpectation
	expectations       []*ProducerMockCloseExpectation
}

// ProducerMockCloseExpectation specifies expectation struct of the Producer.Close
type ProducerMockCloseExpectation struct {
	mock *ProducerMock

	results *ProducerMockCloseResults
	Counter uint64
}

// ProducerMockCloseResults contains results of the Producer.Close
type ProducerMockCloseResults struct {
	err error
}

// Expect sets up expected params for Producer.Close
func (mmClose *mProducerMockClose) Expect() *mProducerMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ProducerMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ProducerMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Producer.Close
func (mmClose *mProducerMockClose) Inspect(f func()) *mProducerMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ProducerMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Producer.Close
func (mmClose *mProducerMockClose) Return(err error) *ProducerMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ProducerMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ProducerMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ProducerMockCloseResults{err}
	return mmClose.mock
}

// Set uses given function f to mock the Producer.Close method
func (mmClose *mProducerMockClose) Set(f func() (err error)) *ProducerMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Producer.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Producer.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements kafka.Producer
func (mmClose *ProducerMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ProducerMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ProducerMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ProducerMock.Close invocations
func (mmClose *ProducerMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ProducerMock.Close invocations
func (mmClose *ProducerMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ProducerMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *ProducerMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ProducerMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ProducerMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ProducerMock.Close")
	}
}

type mProducerMockSendMessage struct {
	mock               *ProducerMock
	defaultExpectation *ProducerMockSendMessageExpectation
	expectations       []*ProducerMockSendMessageExpectation

	callArgs []*ProducerMockSendMessageParams
	mutex    sync.RWMutex
}

// ProducerMockSendMessageExpectation specifies expectation struct of the Producer.SendMessage
type ProducerMockSendMessageExpectation struct {
	mock    *ProducerMock
	params  *ProducerMockSendMessageParams
	results *ProducerMockSendMessageResults
	Counter uint64
}

// ProducerMockSendMessageParams contains parameters of the Producer.SendMessage
type ProducerMockSendMessageParams struct {
	topic   string
	message kafkaModel.Message
}

// ProducerMockSendMessageResults contains results of the Producer.SendMessage
type ProducerMockSendMessageResults struct {
	err error
}

// Expect sets up expected params for Producer.SendMessage
func (mmSendMessage *mProducerMockSendMessage) Expect(topic string, message kafkaModel.Message) *mProducerMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ProducerMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ProducerMockSendMessageExpectation{}
	}

	mmSendMessage.defaultExpectation.params = &ProducerMockSendMessageParams{topic, message}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the Producer.SendMessage
func (mmSendMessage *mProducerMockSendMessage) Inspect(f func(topic string, message kafkaModel.Message)) *mProducerMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ProducerMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by Producer.SendMessage
func (mmSendMessage *mProducerMockSendMessage) Return(err error) *ProducerMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ProducerMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ProducerMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ProducerMockSendMessageResults{err}
	return mmSendMessage.mock
}

// Set uses given function f to mock the Producer.SendMessage method
func (mmSendMessage *mProducerMockSendMessage) Set(f func(topic string, message kafkaModel.Message) (err error)) *ProducerMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the Producer.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the Producer.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the Producer.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mProducerMockSendMessage) When(topic string, message kafkaModel.Message) *ProducerMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ProducerMock.SendMessage mock is already set by Set")
	}

	expectation := &ProducerMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &ProducerMockSendMessageParams{topic, message},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up Producer.SendMessage return parameters for the expectation previously defined by the When method
func (e *ProducerMockSendMessageExpectation) Then(err error) *ProducerMock {
	e.results = &ProducerMockSendMessageResults{err}
	return e.mock
}

// SendMessage implements kafka.Producer
func (mmSendMessage *ProducerMock) SendMessage(topic string, message kafkaModel.Message) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(topic, message)
	}

	mm_params := ProducerMockSendMessageParams{topic, message}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_got := ProducerMockSendMessageParams{topic, message}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ProducerMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ProducerMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(topic, message)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ProducerMock.SendMessage. %v %v", topic, message)
	return
}

// SendMessageAfterCounter returns a count of finished ProducerMock.SendMessage invocations
func (mmSendMessage *ProducerMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ProducerMock.SendMessage invocations
func (mmSendMessage *ProducerMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ProducerMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mProducerMockSendMessage) Calls() []*ProducerMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ProducerMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ProducerMock) MinimockSendMessageDone() bool {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ProducerMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProducerMock.SendMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ProducerMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to ProducerMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		m.t.Error("Expected call to ProducerMock.SendMessage")
	}
}

type mProducerMockTopic struct {
	mock               *ProducerMock
	defaultExpectation *ProducerMockTopicExpectation
	expectations       []*ProducerMockTopicExpectation
}

// ProducerMockTopicExpectation specifies expectation struct of the Producer.Topic
type ProducerMockTopicExpectation struct {
	mock *ProducerMock

	results *ProducerMockTopicResults
	Counter uint64
}

// ProducerMockTopicResults contains results of the Producer.Topic
type ProducerMockTopicResults struct {
	s1 string
}

// Expect sets up expected params for Producer.Topic
func (mmTopic *mProducerMockTopic) Expect() *mProducerMockTopic {
	if mmTopic.mock.funcTopic != nil {
		mmTopic.mock.t.Fatalf("ProducerMock.Topic mock is already set by Set")
	}

	if mmTopic.defaultExpectation == nil {
		mmTopic.defaultExpectation = &ProducerMockTopicExpectation{}
	}

	return mmTopic
}

// Inspect accepts an inspector function that has same arguments as the Producer.Topic
func (mmTopic *mProducerMockTopic) Inspect(f func()) *mProducerMockTopic {
	if mmTopic.mock.inspectFuncTopic != nil {
		mmTopic.mock.t.Fatalf("Inspect function is already set for ProducerMock.Topic")
	}

	mmTopic.mock.inspectFuncTopic = f

	return mmTopic
}

// Return sets up results that will be returned by Producer.Topic
func (mmTopic *mProducerMockTopic) Return(s1 string) *ProducerMock {
	if mmTopic.mock.funcTopic != nil {
		mmTopic.mock.t.Fatalf("ProducerMock.Topic mock is already set by Set")
	}

	if mmTopic.defaultExpectation == nil {
		mmTopic.defaultExpectation = &ProducerMockTopicExpectation{mock: mmTopic.mock}
	}
	mmTopic.defaultExpectation.results = &ProducerMockTopicResults{s1}
	return mmTopic.mock
}

// Set uses given function f to mock the Producer.Topic method
func (mmTopic *mProducerMockTopic) Set(f func() (s1 string)) *ProducerMock {
	if mmTopic.defaultExpectation != nil {
		mmTopic.mock.t.Fatalf("Default expectation is already set for the Producer.Topic method")
	}

	if len(mmTopic.expectations) > 0 {
		mmTopic.mock.t.Fatalf("Some expectations are already set for the Producer.Topic method")
	}

	mmTopic.mock.funcTopic = f
	return mmTopic.mock
}

// Topic implements kafka.Producer
func (mmTopic *ProducerMock) Topic() (s1 string) {
	mm_atomic.AddUint64(&mmTopic.beforeTopicCounter, 1)
	defer mm_atomic.AddUint64(&mmTopic.afterTopicCounter, 1)

	if mmTopic.inspectFuncTopic != nil {
		mmTopic.inspectFuncTopic()
	}

	if mmTopic.TopicMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTopic.TopicMock.defaultExpectation.Counter, 1)

		mm_results := mmTopic.TopicMock.defaultExpectation.results
		if mm_results == nil {
			mmTopic.t.Fatal("No results are set for the ProducerMock.Topic")
		}
		return (*mm_results).s1
	}
	if mmTopic.funcTopic != nil {
		return mmTopic.funcTopic()
	}
	mmTopic.t.Fatalf("Unexpected call to ProducerMock.Topic.")
	return
}

// TopicAfterCounter returns a count of finished ProducerMock.Topic invocations
func (mmTopic *ProducerMock) TopicAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTopic.afterTopicCounter)
}

// TopicBeforeCounter returns a count of ProducerMock.Topic invocations
func (mmTopic *ProducerMock) TopicBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTopic.beforeTopicCounter)
}

// MinimockTopicDone returns true if the count of the Topic invocations corresponds
// the number of defined expectations
func (m *ProducerMock) MinimockTopicDone() bool {
	for _, e := range m.TopicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TopicMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTopicCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTopic != nil && mm_atomic.LoadUint64(&m.afterTopicCounter) < 1 {
		return false
	}
	return true
}

// MinimockTopicInspect logs each unmet expectation
func (m *ProducerMock) MinimockTopicInspect() {
	for _, e := range m.TopicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ProducerMock.Topic")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TopicMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTopicCounter) < 1 {
		m.t.Error("Expected call to ProducerMock.Topic")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTopic != nil && mm_atomic.LoadUint64(&m.afterTopicCounter) < 1 {
		m.t.Error("Expected call to ProducerMock.Topic")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProducerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockSendMessageInspect()

			m.MinimockTopicInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProducerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ProducerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockSendMessageDone() &&
		m.MinimockTopicDone()
}
