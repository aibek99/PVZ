// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mock

import (
	"Homework-1/internal/model/abstract"
	pvzModel "Homework-1/internal/model/pvz"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// UseCaseMock implements pvz.UseCase
type UseCaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreatePVZ          func(ctx context.Context, request pvzModel.Request) (err error)
	inspectFuncCreatePVZ   func(ctx context.Context, request pvzModel.Request)
	afterCreatePVZCounter  uint64
	beforeCreatePVZCounter uint64
	CreatePVZMock          mUseCaseMockCreatePVZ

	funcDeletePVZByID          func(ctx context.Context, pvzID int64) (err error)
	inspectFuncDeletePVZByID   func(ctx context.Context, pvzID int64)
	afterDeletePVZByIDCounter  uint64
	beforeDeletePVZByIDCounter uint64
	DeletePVZByIDMock          mUseCaseMockDeletePVZByID

	funcGetPVZ          func(ctx context.Context, pvzID int64) (a1 pvzModel.AllResponse, err error)
	inspectFuncGetPVZ   func(ctx context.Context, pvzID int64)
	afterGetPVZCounter  uint64
	beforeGetPVZCounter uint64
	GetPVZMock          mUseCaseMockGetPVZ

	funcListPVZ          func(ctx context.Context, pvzPagination abstract.Page) (p1 abstract.PaginatedResponse[pvzModel.AllResponse], err error)
	inspectFuncListPVZ   func(ctx context.Context, pvzPagination abstract.Page)
	afterListPVZCounter  uint64
	beforeListPVZCounter uint64
	ListPVZMock          mUseCaseMockListPVZ

	funcUpdatePVZ          func(ctx context.Context, updatePVZRequest pvzModel.UpdateRequest) (err error)
	inspectFuncUpdatePVZ   func(ctx context.Context, updatePVZRequest pvzModel.UpdateRequest)
	afterUpdatePVZCounter  uint64
	beforeUpdatePVZCounter uint64
	UpdatePVZMock          mUseCaseMockUpdatePVZ
}

// NewUseCaseMock returns a mock for pvz.UseCase
func NewUseCaseMock(t minimock.Tester) *UseCaseMock {
	m := &UseCaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreatePVZMock = mUseCaseMockCreatePVZ{mock: m}
	m.CreatePVZMock.callArgs = []*UseCaseMockCreatePVZParams{}

	m.DeletePVZByIDMock = mUseCaseMockDeletePVZByID{mock: m}
	m.DeletePVZByIDMock.callArgs = []*UseCaseMockDeletePVZByIDParams{}

	m.GetPVZMock = mUseCaseMockGetPVZ{mock: m}
	m.GetPVZMock.callArgs = []*UseCaseMockGetPVZParams{}

	m.ListPVZMock = mUseCaseMockListPVZ{mock: m}
	m.ListPVZMock.callArgs = []*UseCaseMockListPVZParams{}

	m.UpdatePVZMock = mUseCaseMockUpdatePVZ{mock: m}
	m.UpdatePVZMock.callArgs = []*UseCaseMockUpdatePVZParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUseCaseMockCreatePVZ struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockCreatePVZExpectation
	expectations       []*UseCaseMockCreatePVZExpectation

	callArgs []*UseCaseMockCreatePVZParams
	mutex    sync.RWMutex
}

// UseCaseMockCreatePVZExpectation specifies expectation struct of the UseCase.CreatePVZ
type UseCaseMockCreatePVZExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockCreatePVZParams
	results *UseCaseMockCreatePVZResults
	Counter uint64
}

// UseCaseMockCreatePVZParams contains parameters of the UseCase.CreatePVZ
type UseCaseMockCreatePVZParams struct {
	ctx     context.Context
	request pvzModel.Request
}

// UseCaseMockCreatePVZResults contains results of the UseCase.CreatePVZ
type UseCaseMockCreatePVZResults struct {
	err error
}

// Expect sets up expected params for UseCase.CreatePVZ
func (mmCreatePVZ *mUseCaseMockCreatePVZ) Expect(ctx context.Context, request pvzModel.Request) *mUseCaseMockCreatePVZ {
	if mmCreatePVZ.mock.funcCreatePVZ != nil {
		mmCreatePVZ.mock.t.Fatalf("UseCaseMock.CreatePVZ mock is already set by Set")
	}

	if mmCreatePVZ.defaultExpectation == nil {
		mmCreatePVZ.defaultExpectation = &UseCaseMockCreatePVZExpectation{}
	}

	mmCreatePVZ.defaultExpectation.params = &UseCaseMockCreatePVZParams{ctx, request}
	for _, e := range mmCreatePVZ.expectations {
		if minimock.Equal(e.params, mmCreatePVZ.defaultExpectation.params) {
			mmCreatePVZ.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePVZ.defaultExpectation.params)
		}
	}

	return mmCreatePVZ
}

// Inspect accepts an inspector function that has same arguments as the UseCase.CreatePVZ
func (mmCreatePVZ *mUseCaseMockCreatePVZ) Inspect(f func(ctx context.Context, request pvzModel.Request)) *mUseCaseMockCreatePVZ {
	if mmCreatePVZ.mock.inspectFuncCreatePVZ != nil {
		mmCreatePVZ.mock.t.Fatalf("Inspect function is already set for UseCaseMock.CreatePVZ")
	}

	mmCreatePVZ.mock.inspectFuncCreatePVZ = f

	return mmCreatePVZ
}

// Return sets up results that will be returned by UseCase.CreatePVZ
func (mmCreatePVZ *mUseCaseMockCreatePVZ) Return(err error) *UseCaseMock {
	if mmCreatePVZ.mock.funcCreatePVZ != nil {
		mmCreatePVZ.mock.t.Fatalf("UseCaseMock.CreatePVZ mock is already set by Set")
	}

	if mmCreatePVZ.defaultExpectation == nil {
		mmCreatePVZ.defaultExpectation = &UseCaseMockCreatePVZExpectation{mock: mmCreatePVZ.mock}
	}
	mmCreatePVZ.defaultExpectation.results = &UseCaseMockCreatePVZResults{err}
	return mmCreatePVZ.mock
}

// Set uses given function f to mock the UseCase.CreatePVZ method
func (mmCreatePVZ *mUseCaseMockCreatePVZ) Set(f func(ctx context.Context, request pvzModel.Request) (err error)) *UseCaseMock {
	if mmCreatePVZ.defaultExpectation != nil {
		mmCreatePVZ.mock.t.Fatalf("Default expectation is already set for the UseCase.CreatePVZ method")
	}

	if len(mmCreatePVZ.expectations) > 0 {
		mmCreatePVZ.mock.t.Fatalf("Some expectations are already set for the UseCase.CreatePVZ method")
	}

	mmCreatePVZ.mock.funcCreatePVZ = f
	return mmCreatePVZ.mock
}

// When sets expectation for the UseCase.CreatePVZ which will trigger the result defined by the following
// Then helper
func (mmCreatePVZ *mUseCaseMockCreatePVZ) When(ctx context.Context, request pvzModel.Request) *UseCaseMockCreatePVZExpectation {
	if mmCreatePVZ.mock.funcCreatePVZ != nil {
		mmCreatePVZ.mock.t.Fatalf("UseCaseMock.CreatePVZ mock is already set by Set")
	}

	expectation := &UseCaseMockCreatePVZExpectation{
		mock:   mmCreatePVZ.mock,
		params: &UseCaseMockCreatePVZParams{ctx, request},
	}
	mmCreatePVZ.expectations = append(mmCreatePVZ.expectations, expectation)
	return expectation
}

// Then sets up UseCase.CreatePVZ return parameters for the expectation previously defined by the When method
func (e *UseCaseMockCreatePVZExpectation) Then(err error) *UseCaseMock {
	e.results = &UseCaseMockCreatePVZResults{err}
	return e.mock
}

// CreatePVZ implements pvz.UseCase
func (mmCreatePVZ *UseCaseMock) CreatePVZ(ctx context.Context, request pvzModel.Request) (err error) {
	mm_atomic.AddUint64(&mmCreatePVZ.beforeCreatePVZCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePVZ.afterCreatePVZCounter, 1)

	if mmCreatePVZ.inspectFuncCreatePVZ != nil {
		mmCreatePVZ.inspectFuncCreatePVZ(ctx, request)
	}

	mm_params := UseCaseMockCreatePVZParams{ctx, request}

	// Record call args
	mmCreatePVZ.CreatePVZMock.mutex.Lock()
	mmCreatePVZ.CreatePVZMock.callArgs = append(mmCreatePVZ.CreatePVZMock.callArgs, &mm_params)
	mmCreatePVZ.CreatePVZMock.mutex.Unlock()

	for _, e := range mmCreatePVZ.CreatePVZMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreatePVZ.CreatePVZMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePVZ.CreatePVZMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePVZ.CreatePVZMock.defaultExpectation.params
		mm_got := UseCaseMockCreatePVZParams{ctx, request}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePVZ.t.Errorf("UseCaseMock.CreatePVZ got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePVZ.CreatePVZMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePVZ.t.Fatal("No results are set for the UseCaseMock.CreatePVZ")
		}
		return (*mm_results).err
	}
	if mmCreatePVZ.funcCreatePVZ != nil {
		return mmCreatePVZ.funcCreatePVZ(ctx, request)
	}
	mmCreatePVZ.t.Fatalf("Unexpected call to UseCaseMock.CreatePVZ. %v %v", ctx, request)
	return
}

// CreatePVZAfterCounter returns a count of finished UseCaseMock.CreatePVZ invocations
func (mmCreatePVZ *UseCaseMock) CreatePVZAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePVZ.afterCreatePVZCounter)
}

// CreatePVZBeforeCounter returns a count of UseCaseMock.CreatePVZ invocations
func (mmCreatePVZ *UseCaseMock) CreatePVZBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePVZ.beforeCreatePVZCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.CreatePVZ.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePVZ *mUseCaseMockCreatePVZ) Calls() []*UseCaseMockCreatePVZParams {
	mmCreatePVZ.mutex.RLock()

	argCopy := make([]*UseCaseMockCreatePVZParams, len(mmCreatePVZ.callArgs))
	copy(argCopy, mmCreatePVZ.callArgs)

	mmCreatePVZ.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePVZDone returns true if the count of the CreatePVZ invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockCreatePVZDone() bool {
	for _, e := range m.CreatePVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePVZMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreatePVZCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePVZ != nil && mm_atomic.LoadUint64(&m.afterCreatePVZCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreatePVZInspect logs each unmet expectation
func (m *UseCaseMock) MinimockCreatePVZInspect() {
	for _, e := range m.CreatePVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.CreatePVZ with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePVZMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreatePVZCounter) < 1 {
		if m.CreatePVZMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.CreatePVZ")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.CreatePVZ with params: %#v", *m.CreatePVZMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePVZ != nil && mm_atomic.LoadUint64(&m.afterCreatePVZCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.CreatePVZ")
	}
}

type mUseCaseMockDeletePVZByID struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockDeletePVZByIDExpectation
	expectations       []*UseCaseMockDeletePVZByIDExpectation

	callArgs []*UseCaseMockDeletePVZByIDParams
	mutex    sync.RWMutex
}

// UseCaseMockDeletePVZByIDExpectation specifies expectation struct of the UseCase.DeletePVZByID
type UseCaseMockDeletePVZByIDExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockDeletePVZByIDParams
	results *UseCaseMockDeletePVZByIDResults
	Counter uint64
}

// UseCaseMockDeletePVZByIDParams contains parameters of the UseCase.DeletePVZByID
type UseCaseMockDeletePVZByIDParams struct {
	ctx   context.Context
	pvzID int64
}

// UseCaseMockDeletePVZByIDResults contains results of the UseCase.DeletePVZByID
type UseCaseMockDeletePVZByIDResults struct {
	err error
}

// Expect sets up expected params for UseCase.DeletePVZByID
func (mmDeletePVZByID *mUseCaseMockDeletePVZByID) Expect(ctx context.Context, pvzID int64) *mUseCaseMockDeletePVZByID {
	if mmDeletePVZByID.mock.funcDeletePVZByID != nil {
		mmDeletePVZByID.mock.t.Fatalf("UseCaseMock.DeletePVZByID mock is already set by Set")
	}

	if mmDeletePVZByID.defaultExpectation == nil {
		mmDeletePVZByID.defaultExpectation = &UseCaseMockDeletePVZByIDExpectation{}
	}

	mmDeletePVZByID.defaultExpectation.params = &UseCaseMockDeletePVZByIDParams{ctx, pvzID}
	for _, e := range mmDeletePVZByID.expectations {
		if minimock.Equal(e.params, mmDeletePVZByID.defaultExpectation.params) {
			mmDeletePVZByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePVZByID.defaultExpectation.params)
		}
	}

	return mmDeletePVZByID
}

// Inspect accepts an inspector function that has same arguments as the UseCase.DeletePVZByID
func (mmDeletePVZByID *mUseCaseMockDeletePVZByID) Inspect(f func(ctx context.Context, pvzID int64)) *mUseCaseMockDeletePVZByID {
	if mmDeletePVZByID.mock.inspectFuncDeletePVZByID != nil {
		mmDeletePVZByID.mock.t.Fatalf("Inspect function is already set for UseCaseMock.DeletePVZByID")
	}

	mmDeletePVZByID.mock.inspectFuncDeletePVZByID = f

	return mmDeletePVZByID
}

// Return sets up results that will be returned by UseCase.DeletePVZByID
func (mmDeletePVZByID *mUseCaseMockDeletePVZByID) Return(err error) *UseCaseMock {
	if mmDeletePVZByID.mock.funcDeletePVZByID != nil {
		mmDeletePVZByID.mock.t.Fatalf("UseCaseMock.DeletePVZByID mock is already set by Set")
	}

	if mmDeletePVZByID.defaultExpectation == nil {
		mmDeletePVZByID.defaultExpectation = &UseCaseMockDeletePVZByIDExpectation{mock: mmDeletePVZByID.mock}
	}
	mmDeletePVZByID.defaultExpectation.results = &UseCaseMockDeletePVZByIDResults{err}
	return mmDeletePVZByID.mock
}

// Set uses given function f to mock the UseCase.DeletePVZByID method
func (mmDeletePVZByID *mUseCaseMockDeletePVZByID) Set(f func(ctx context.Context, pvzID int64) (err error)) *UseCaseMock {
	if mmDeletePVZByID.defaultExpectation != nil {
		mmDeletePVZByID.mock.t.Fatalf("Default expectation is already set for the UseCase.DeletePVZByID method")
	}

	if len(mmDeletePVZByID.expectations) > 0 {
		mmDeletePVZByID.mock.t.Fatalf("Some expectations are already set for the UseCase.DeletePVZByID method")
	}

	mmDeletePVZByID.mock.funcDeletePVZByID = f
	return mmDeletePVZByID.mock
}

// When sets expectation for the UseCase.DeletePVZByID which will trigger the result defined by the following
// Then helper
func (mmDeletePVZByID *mUseCaseMockDeletePVZByID) When(ctx context.Context, pvzID int64) *UseCaseMockDeletePVZByIDExpectation {
	if mmDeletePVZByID.mock.funcDeletePVZByID != nil {
		mmDeletePVZByID.mock.t.Fatalf("UseCaseMock.DeletePVZByID mock is already set by Set")
	}

	expectation := &UseCaseMockDeletePVZByIDExpectation{
		mock:   mmDeletePVZByID.mock,
		params: &UseCaseMockDeletePVZByIDParams{ctx, pvzID},
	}
	mmDeletePVZByID.expectations = append(mmDeletePVZByID.expectations, expectation)
	return expectation
}

// Then sets up UseCase.DeletePVZByID return parameters for the expectation previously defined by the When method
func (e *UseCaseMockDeletePVZByIDExpectation) Then(err error) *UseCaseMock {
	e.results = &UseCaseMockDeletePVZByIDResults{err}
	return e.mock
}

// DeletePVZByID implements pvz.UseCase
func (mmDeletePVZByID *UseCaseMock) DeletePVZByID(ctx context.Context, pvzID int64) (err error) {
	mm_atomic.AddUint64(&mmDeletePVZByID.beforeDeletePVZByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePVZByID.afterDeletePVZByIDCounter, 1)

	if mmDeletePVZByID.inspectFuncDeletePVZByID != nil {
		mmDeletePVZByID.inspectFuncDeletePVZByID(ctx, pvzID)
	}

	mm_params := UseCaseMockDeletePVZByIDParams{ctx, pvzID}

	// Record call args
	mmDeletePVZByID.DeletePVZByIDMock.mutex.Lock()
	mmDeletePVZByID.DeletePVZByIDMock.callArgs = append(mmDeletePVZByID.DeletePVZByIDMock.callArgs, &mm_params)
	mmDeletePVZByID.DeletePVZByIDMock.mutex.Unlock()

	for _, e := range mmDeletePVZByID.DeletePVZByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePVZByID.DeletePVZByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePVZByID.DeletePVZByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePVZByID.DeletePVZByIDMock.defaultExpectation.params
		mm_got := UseCaseMockDeletePVZByIDParams{ctx, pvzID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePVZByID.t.Errorf("UseCaseMock.DeletePVZByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePVZByID.DeletePVZByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePVZByID.t.Fatal("No results are set for the UseCaseMock.DeletePVZByID")
		}
		return (*mm_results).err
	}
	if mmDeletePVZByID.funcDeletePVZByID != nil {
		return mmDeletePVZByID.funcDeletePVZByID(ctx, pvzID)
	}
	mmDeletePVZByID.t.Fatalf("Unexpected call to UseCaseMock.DeletePVZByID. %v %v", ctx, pvzID)
	return
}

// DeletePVZByIDAfterCounter returns a count of finished UseCaseMock.DeletePVZByID invocations
func (mmDeletePVZByID *UseCaseMock) DeletePVZByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePVZByID.afterDeletePVZByIDCounter)
}

// DeletePVZByIDBeforeCounter returns a count of UseCaseMock.DeletePVZByID invocations
func (mmDeletePVZByID *UseCaseMock) DeletePVZByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePVZByID.beforeDeletePVZByIDCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.DeletePVZByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePVZByID *mUseCaseMockDeletePVZByID) Calls() []*UseCaseMockDeletePVZByIDParams {
	mmDeletePVZByID.mutex.RLock()

	argCopy := make([]*UseCaseMockDeletePVZByIDParams, len(mmDeletePVZByID.callArgs))
	copy(argCopy, mmDeletePVZByID.callArgs)

	mmDeletePVZByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePVZByIDDone returns true if the count of the DeletePVZByID invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockDeletePVZByIDDone() bool {
	for _, e := range m.DeletePVZByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePVZByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeletePVZByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePVZByID != nil && mm_atomic.LoadUint64(&m.afterDeletePVZByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeletePVZByIDInspect logs each unmet expectation
func (m *UseCaseMock) MinimockDeletePVZByIDInspect() {
	for _, e := range m.DeletePVZByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.DeletePVZByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePVZByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeletePVZByIDCounter) < 1 {
		if m.DeletePVZByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.DeletePVZByID")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.DeletePVZByID with params: %#v", *m.DeletePVZByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePVZByID != nil && mm_atomic.LoadUint64(&m.afterDeletePVZByIDCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.DeletePVZByID")
	}
}

type mUseCaseMockGetPVZ struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockGetPVZExpectation
	expectations       []*UseCaseMockGetPVZExpectation

	callArgs []*UseCaseMockGetPVZParams
	mutex    sync.RWMutex
}

// UseCaseMockGetPVZExpectation specifies expectation struct of the UseCase.GetPVZ
type UseCaseMockGetPVZExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockGetPVZParams
	results *UseCaseMockGetPVZResults
	Counter uint64
}

// UseCaseMockGetPVZParams contains parameters of the UseCase.GetPVZ
type UseCaseMockGetPVZParams struct {
	ctx   context.Context
	pvzID int64
}

// UseCaseMockGetPVZResults contains results of the UseCase.GetPVZ
type UseCaseMockGetPVZResults struct {
	a1  pvzModel.AllResponse
	err error
}

// Expect sets up expected params for UseCase.GetPVZ
func (mmGetPVZ *mUseCaseMockGetPVZ) Expect(ctx context.Context, pvzID int64) *mUseCaseMockGetPVZ {
	if mmGetPVZ.mock.funcGetPVZ != nil {
		mmGetPVZ.mock.t.Fatalf("UseCaseMock.GetPVZ mock is already set by Set")
	}

	if mmGetPVZ.defaultExpectation == nil {
		mmGetPVZ.defaultExpectation = &UseCaseMockGetPVZExpectation{}
	}

	mmGetPVZ.defaultExpectation.params = &UseCaseMockGetPVZParams{ctx, pvzID}
	for _, e := range mmGetPVZ.expectations {
		if minimock.Equal(e.params, mmGetPVZ.defaultExpectation.params) {
			mmGetPVZ.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPVZ.defaultExpectation.params)
		}
	}

	return mmGetPVZ
}

// Inspect accepts an inspector function that has same arguments as the UseCase.GetPVZ
func (mmGetPVZ *mUseCaseMockGetPVZ) Inspect(f func(ctx context.Context, pvzID int64)) *mUseCaseMockGetPVZ {
	if mmGetPVZ.mock.inspectFuncGetPVZ != nil {
		mmGetPVZ.mock.t.Fatalf("Inspect function is already set for UseCaseMock.GetPVZ")
	}

	mmGetPVZ.mock.inspectFuncGetPVZ = f

	return mmGetPVZ
}

// Return sets up results that will be returned by UseCase.GetPVZ
func (mmGetPVZ *mUseCaseMockGetPVZ) Return(a1 pvzModel.AllResponse, err error) *UseCaseMock {
	if mmGetPVZ.mock.funcGetPVZ != nil {
		mmGetPVZ.mock.t.Fatalf("UseCaseMock.GetPVZ mock is already set by Set")
	}

	if mmGetPVZ.defaultExpectation == nil {
		mmGetPVZ.defaultExpectation = &UseCaseMockGetPVZExpectation{mock: mmGetPVZ.mock}
	}
	mmGetPVZ.defaultExpectation.results = &UseCaseMockGetPVZResults{a1, err}
	return mmGetPVZ.mock
}

// Set uses given function f to mock the UseCase.GetPVZ method
func (mmGetPVZ *mUseCaseMockGetPVZ) Set(f func(ctx context.Context, pvzID int64) (a1 pvzModel.AllResponse, err error)) *UseCaseMock {
	if mmGetPVZ.defaultExpectation != nil {
		mmGetPVZ.mock.t.Fatalf("Default expectation is already set for the UseCase.GetPVZ method")
	}

	if len(mmGetPVZ.expectations) > 0 {
		mmGetPVZ.mock.t.Fatalf("Some expectations are already set for the UseCase.GetPVZ method")
	}

	mmGetPVZ.mock.funcGetPVZ = f
	return mmGetPVZ.mock
}

// When sets expectation for the UseCase.GetPVZ which will trigger the result defined by the following
// Then helper
func (mmGetPVZ *mUseCaseMockGetPVZ) When(ctx context.Context, pvzID int64) *UseCaseMockGetPVZExpectation {
	if mmGetPVZ.mock.funcGetPVZ != nil {
		mmGetPVZ.mock.t.Fatalf("UseCaseMock.GetPVZ mock is already set by Set")
	}

	expectation := &UseCaseMockGetPVZExpectation{
		mock:   mmGetPVZ.mock,
		params: &UseCaseMockGetPVZParams{ctx, pvzID},
	}
	mmGetPVZ.expectations = append(mmGetPVZ.expectations, expectation)
	return expectation
}

// Then sets up UseCase.GetPVZ return parameters for the expectation previously defined by the When method
func (e *UseCaseMockGetPVZExpectation) Then(a1 pvzModel.AllResponse, err error) *UseCaseMock {
	e.results = &UseCaseMockGetPVZResults{a1, err}
	return e.mock
}

// GetPVZ implements pvz.UseCase
func (mmGetPVZ *UseCaseMock) GetPVZ(ctx context.Context, pvzID int64) (a1 pvzModel.AllResponse, err error) {
	mm_atomic.AddUint64(&mmGetPVZ.beforeGetPVZCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPVZ.afterGetPVZCounter, 1)

	if mmGetPVZ.inspectFuncGetPVZ != nil {
		mmGetPVZ.inspectFuncGetPVZ(ctx, pvzID)
	}

	mm_params := UseCaseMockGetPVZParams{ctx, pvzID}

	// Record call args
	mmGetPVZ.GetPVZMock.mutex.Lock()
	mmGetPVZ.GetPVZMock.callArgs = append(mmGetPVZ.GetPVZMock.callArgs, &mm_params)
	mmGetPVZ.GetPVZMock.mutex.Unlock()

	for _, e := range mmGetPVZ.GetPVZMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1, e.results.err
		}
	}

	if mmGetPVZ.GetPVZMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPVZ.GetPVZMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPVZ.GetPVZMock.defaultExpectation.params
		mm_got := UseCaseMockGetPVZParams{ctx, pvzID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPVZ.t.Errorf("UseCaseMock.GetPVZ got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPVZ.GetPVZMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPVZ.t.Fatal("No results are set for the UseCaseMock.GetPVZ")
		}
		return (*mm_results).a1, (*mm_results).err
	}
	if mmGetPVZ.funcGetPVZ != nil {
		return mmGetPVZ.funcGetPVZ(ctx, pvzID)
	}
	mmGetPVZ.t.Fatalf("Unexpected call to UseCaseMock.GetPVZ. %v %v", ctx, pvzID)
	return
}

// GetPVZAfterCounter returns a count of finished UseCaseMock.GetPVZ invocations
func (mmGetPVZ *UseCaseMock) GetPVZAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPVZ.afterGetPVZCounter)
}

// GetPVZBeforeCounter returns a count of UseCaseMock.GetPVZ invocations
func (mmGetPVZ *UseCaseMock) GetPVZBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPVZ.beforeGetPVZCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.GetPVZ.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPVZ *mUseCaseMockGetPVZ) Calls() []*UseCaseMockGetPVZParams {
	mmGetPVZ.mutex.RLock()

	argCopy := make([]*UseCaseMockGetPVZParams, len(mmGetPVZ.callArgs))
	copy(argCopy, mmGetPVZ.callArgs)

	mmGetPVZ.mutex.RUnlock()

	return argCopy
}

// MinimockGetPVZDone returns true if the count of the GetPVZ invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockGetPVZDone() bool {
	for _, e := range m.GetPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPVZMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPVZCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPVZ != nil && mm_atomic.LoadUint64(&m.afterGetPVZCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPVZInspect logs each unmet expectation
func (m *UseCaseMock) MinimockGetPVZInspect() {
	for _, e := range m.GetPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.GetPVZ with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPVZMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPVZCounter) < 1 {
		if m.GetPVZMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.GetPVZ")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.GetPVZ with params: %#v", *m.GetPVZMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPVZ != nil && mm_atomic.LoadUint64(&m.afterGetPVZCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.GetPVZ")
	}
}

type mUseCaseMockListPVZ struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockListPVZExpectation
	expectations       []*UseCaseMockListPVZExpectation

	callArgs []*UseCaseMockListPVZParams
	mutex    sync.RWMutex
}

// UseCaseMockListPVZExpectation specifies expectation struct of the UseCase.ListPVZ
type UseCaseMockListPVZExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockListPVZParams
	results *UseCaseMockListPVZResults
	Counter uint64
}

// UseCaseMockListPVZParams contains parameters of the UseCase.ListPVZ
type UseCaseMockListPVZParams struct {
	ctx           context.Context
	pvzPagination abstract.Page
}

// UseCaseMockListPVZResults contains results of the UseCase.ListPVZ
type UseCaseMockListPVZResults struct {
	p1  abstract.PaginatedResponse[pvzModel.AllResponse]
	err error
}

// Expect sets up expected params for UseCase.ListPVZ
func (mmListPVZ *mUseCaseMockListPVZ) Expect(ctx context.Context, pvzPagination abstract.Page) *mUseCaseMockListPVZ {
	if mmListPVZ.mock.funcListPVZ != nil {
		mmListPVZ.mock.t.Fatalf("UseCaseMock.ListPVZ mock is already set by Set")
	}

	if mmListPVZ.defaultExpectation == nil {
		mmListPVZ.defaultExpectation = &UseCaseMockListPVZExpectation{}
	}

	mmListPVZ.defaultExpectation.params = &UseCaseMockListPVZParams{ctx, pvzPagination}
	for _, e := range mmListPVZ.expectations {
		if minimock.Equal(e.params, mmListPVZ.defaultExpectation.params) {
			mmListPVZ.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPVZ.defaultExpectation.params)
		}
	}

	return mmListPVZ
}

// Inspect accepts an inspector function that has same arguments as the UseCase.ListPVZ
func (mmListPVZ *mUseCaseMockListPVZ) Inspect(f func(ctx context.Context, pvzPagination abstract.Page)) *mUseCaseMockListPVZ {
	if mmListPVZ.mock.inspectFuncListPVZ != nil {
		mmListPVZ.mock.t.Fatalf("Inspect function is already set for UseCaseMock.ListPVZ")
	}

	mmListPVZ.mock.inspectFuncListPVZ = f

	return mmListPVZ
}

// Return sets up results that will be returned by UseCase.ListPVZ
func (mmListPVZ *mUseCaseMockListPVZ) Return(p1 abstract.PaginatedResponse[pvzModel.AllResponse], err error) *UseCaseMock {
	if mmListPVZ.mock.funcListPVZ != nil {
		mmListPVZ.mock.t.Fatalf("UseCaseMock.ListPVZ mock is already set by Set")
	}

	if mmListPVZ.defaultExpectation == nil {
		mmListPVZ.defaultExpectation = &UseCaseMockListPVZExpectation{mock: mmListPVZ.mock}
	}
	mmListPVZ.defaultExpectation.results = &UseCaseMockListPVZResults{p1, err}
	return mmListPVZ.mock
}

// Set uses given function f to mock the UseCase.ListPVZ method
func (mmListPVZ *mUseCaseMockListPVZ) Set(f func(ctx context.Context, pvzPagination abstract.Page) (p1 abstract.PaginatedResponse[pvzModel.AllResponse], err error)) *UseCaseMock {
	if mmListPVZ.defaultExpectation != nil {
		mmListPVZ.mock.t.Fatalf("Default expectation is already set for the UseCase.ListPVZ method")
	}

	if len(mmListPVZ.expectations) > 0 {
		mmListPVZ.mock.t.Fatalf("Some expectations are already set for the UseCase.ListPVZ method")
	}

	mmListPVZ.mock.funcListPVZ = f
	return mmListPVZ.mock
}

// When sets expectation for the UseCase.ListPVZ which will trigger the result defined by the following
// Then helper
func (mmListPVZ *mUseCaseMockListPVZ) When(ctx context.Context, pvzPagination abstract.Page) *UseCaseMockListPVZExpectation {
	if mmListPVZ.mock.funcListPVZ != nil {
		mmListPVZ.mock.t.Fatalf("UseCaseMock.ListPVZ mock is already set by Set")
	}

	expectation := &UseCaseMockListPVZExpectation{
		mock:   mmListPVZ.mock,
		params: &UseCaseMockListPVZParams{ctx, pvzPagination},
	}
	mmListPVZ.expectations = append(mmListPVZ.expectations, expectation)
	return expectation
}

// Then sets up UseCase.ListPVZ return parameters for the expectation previously defined by the When method
func (e *UseCaseMockListPVZExpectation) Then(p1 abstract.PaginatedResponse[pvzModel.AllResponse], err error) *UseCaseMock {
	e.results = &UseCaseMockListPVZResults{p1, err}
	return e.mock
}

// ListPVZ implements pvz.UseCase
func (mmListPVZ *UseCaseMock) ListPVZ(ctx context.Context, pvzPagination abstract.Page) (p1 abstract.PaginatedResponse[pvzModel.AllResponse], err error) {
	mm_atomic.AddUint64(&mmListPVZ.beforeListPVZCounter, 1)
	defer mm_atomic.AddUint64(&mmListPVZ.afterListPVZCounter, 1)

	if mmListPVZ.inspectFuncListPVZ != nil {
		mmListPVZ.inspectFuncListPVZ(ctx, pvzPagination)
	}

	mm_params := UseCaseMockListPVZParams{ctx, pvzPagination}

	// Record call args
	mmListPVZ.ListPVZMock.mutex.Lock()
	mmListPVZ.ListPVZMock.callArgs = append(mmListPVZ.ListPVZMock.callArgs, &mm_params)
	mmListPVZ.ListPVZMock.mutex.Unlock()

	for _, e := range mmListPVZ.ListPVZMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmListPVZ.ListPVZMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPVZ.ListPVZMock.defaultExpectation.Counter, 1)
		mm_want := mmListPVZ.ListPVZMock.defaultExpectation.params
		mm_got := UseCaseMockListPVZParams{ctx, pvzPagination}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPVZ.t.Errorf("UseCaseMock.ListPVZ got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPVZ.ListPVZMock.defaultExpectation.results
		if mm_results == nil {
			mmListPVZ.t.Fatal("No results are set for the UseCaseMock.ListPVZ")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmListPVZ.funcListPVZ != nil {
		return mmListPVZ.funcListPVZ(ctx, pvzPagination)
	}
	mmListPVZ.t.Fatalf("Unexpected call to UseCaseMock.ListPVZ. %v %v", ctx, pvzPagination)
	return
}

// ListPVZAfterCounter returns a count of finished UseCaseMock.ListPVZ invocations
func (mmListPVZ *UseCaseMock) ListPVZAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPVZ.afterListPVZCounter)
}

// ListPVZBeforeCounter returns a count of UseCaseMock.ListPVZ invocations
func (mmListPVZ *UseCaseMock) ListPVZBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPVZ.beforeListPVZCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.ListPVZ.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPVZ *mUseCaseMockListPVZ) Calls() []*UseCaseMockListPVZParams {
	mmListPVZ.mutex.RLock()

	argCopy := make([]*UseCaseMockListPVZParams, len(mmListPVZ.callArgs))
	copy(argCopy, mmListPVZ.callArgs)

	mmListPVZ.mutex.RUnlock()

	return argCopy
}

// MinimockListPVZDone returns true if the count of the ListPVZ invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockListPVZDone() bool {
	for _, e := range m.ListPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListPVZMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListPVZCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPVZ != nil && mm_atomic.LoadUint64(&m.afterListPVZCounter) < 1 {
		return false
	}
	return true
}

// MinimockListPVZInspect logs each unmet expectation
func (m *UseCaseMock) MinimockListPVZInspect() {
	for _, e := range m.ListPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.ListPVZ with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListPVZMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListPVZCounter) < 1 {
		if m.ListPVZMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.ListPVZ")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.ListPVZ with params: %#v", *m.ListPVZMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPVZ != nil && mm_atomic.LoadUint64(&m.afterListPVZCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.ListPVZ")
	}
}

type mUseCaseMockUpdatePVZ struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockUpdatePVZExpectation
	expectations       []*UseCaseMockUpdatePVZExpectation

	callArgs []*UseCaseMockUpdatePVZParams
	mutex    sync.RWMutex
}

// UseCaseMockUpdatePVZExpectation specifies expectation struct of the UseCase.UpdatePVZ
type UseCaseMockUpdatePVZExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockUpdatePVZParams
	results *UseCaseMockUpdatePVZResults
	Counter uint64
}

// UseCaseMockUpdatePVZParams contains parameters of the UseCase.UpdatePVZ
type UseCaseMockUpdatePVZParams struct {
	ctx              context.Context
	updatePVZRequest pvzModel.UpdateRequest
}

// UseCaseMockUpdatePVZResults contains results of the UseCase.UpdatePVZ
type UseCaseMockUpdatePVZResults struct {
	err error
}

// Expect sets up expected params for UseCase.UpdatePVZ
func (mmUpdatePVZ *mUseCaseMockUpdatePVZ) Expect(ctx context.Context, updatePVZRequest pvzModel.UpdateRequest) *mUseCaseMockUpdatePVZ {
	if mmUpdatePVZ.mock.funcUpdatePVZ != nil {
		mmUpdatePVZ.mock.t.Fatalf("UseCaseMock.UpdatePVZ mock is already set by Set")
	}

	if mmUpdatePVZ.defaultExpectation == nil {
		mmUpdatePVZ.defaultExpectation = &UseCaseMockUpdatePVZExpectation{}
	}

	mmUpdatePVZ.defaultExpectation.params = &UseCaseMockUpdatePVZParams{ctx, updatePVZRequest}
	for _, e := range mmUpdatePVZ.expectations {
		if minimock.Equal(e.params, mmUpdatePVZ.defaultExpectation.params) {
			mmUpdatePVZ.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePVZ.defaultExpectation.params)
		}
	}

	return mmUpdatePVZ
}

// Inspect accepts an inspector function that has same arguments as the UseCase.UpdatePVZ
func (mmUpdatePVZ *mUseCaseMockUpdatePVZ) Inspect(f func(ctx context.Context, updatePVZRequest pvzModel.UpdateRequest)) *mUseCaseMockUpdatePVZ {
	if mmUpdatePVZ.mock.inspectFuncUpdatePVZ != nil {
		mmUpdatePVZ.mock.t.Fatalf("Inspect function is already set for UseCaseMock.UpdatePVZ")
	}

	mmUpdatePVZ.mock.inspectFuncUpdatePVZ = f

	return mmUpdatePVZ
}

// Return sets up results that will be returned by UseCase.UpdatePVZ
func (mmUpdatePVZ *mUseCaseMockUpdatePVZ) Return(err error) *UseCaseMock {
	if mmUpdatePVZ.mock.funcUpdatePVZ != nil {
		mmUpdatePVZ.mock.t.Fatalf("UseCaseMock.UpdatePVZ mock is already set by Set")
	}

	if mmUpdatePVZ.defaultExpectation == nil {
		mmUpdatePVZ.defaultExpectation = &UseCaseMockUpdatePVZExpectation{mock: mmUpdatePVZ.mock}
	}
	mmUpdatePVZ.defaultExpectation.results = &UseCaseMockUpdatePVZResults{err}
	return mmUpdatePVZ.mock
}

// Set uses given function f to mock the UseCase.UpdatePVZ method
func (mmUpdatePVZ *mUseCaseMockUpdatePVZ) Set(f func(ctx context.Context, updatePVZRequest pvzModel.UpdateRequest) (err error)) *UseCaseMock {
	if mmUpdatePVZ.defaultExpectation != nil {
		mmUpdatePVZ.mock.t.Fatalf("Default expectation is already set for the UseCase.UpdatePVZ method")
	}

	if len(mmUpdatePVZ.expectations) > 0 {
		mmUpdatePVZ.mock.t.Fatalf("Some expectations are already set for the UseCase.UpdatePVZ method")
	}

	mmUpdatePVZ.mock.funcUpdatePVZ = f
	return mmUpdatePVZ.mock
}

// When sets expectation for the UseCase.UpdatePVZ which will trigger the result defined by the following
// Then helper
func (mmUpdatePVZ *mUseCaseMockUpdatePVZ) When(ctx context.Context, updatePVZRequest pvzModel.UpdateRequest) *UseCaseMockUpdatePVZExpectation {
	if mmUpdatePVZ.mock.funcUpdatePVZ != nil {
		mmUpdatePVZ.mock.t.Fatalf("UseCaseMock.UpdatePVZ mock is already set by Set")
	}

	expectation := &UseCaseMockUpdatePVZExpectation{
		mock:   mmUpdatePVZ.mock,
		params: &UseCaseMockUpdatePVZParams{ctx, updatePVZRequest},
	}
	mmUpdatePVZ.expectations = append(mmUpdatePVZ.expectations, expectation)
	return expectation
}

// Then sets up UseCase.UpdatePVZ return parameters for the expectation previously defined by the When method
func (e *UseCaseMockUpdatePVZExpectation) Then(err error) *UseCaseMock {
	e.results = &UseCaseMockUpdatePVZResults{err}
	return e.mock
}

// UpdatePVZ implements pvz.UseCase
func (mmUpdatePVZ *UseCaseMock) UpdatePVZ(ctx context.Context, updatePVZRequest pvzModel.UpdateRequest) (err error) {
	mm_atomic.AddUint64(&mmUpdatePVZ.beforeUpdatePVZCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePVZ.afterUpdatePVZCounter, 1)

	if mmUpdatePVZ.inspectFuncUpdatePVZ != nil {
		mmUpdatePVZ.inspectFuncUpdatePVZ(ctx, updatePVZRequest)
	}

	mm_params := UseCaseMockUpdatePVZParams{ctx, updatePVZRequest}

	// Record call args
	mmUpdatePVZ.UpdatePVZMock.mutex.Lock()
	mmUpdatePVZ.UpdatePVZMock.callArgs = append(mmUpdatePVZ.UpdatePVZMock.callArgs, &mm_params)
	mmUpdatePVZ.UpdatePVZMock.mutex.Unlock()

	for _, e := range mmUpdatePVZ.UpdatePVZMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdatePVZ.UpdatePVZMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePVZ.UpdatePVZMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePVZ.UpdatePVZMock.defaultExpectation.params
		mm_got := UseCaseMockUpdatePVZParams{ctx, updatePVZRequest}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePVZ.t.Errorf("UseCaseMock.UpdatePVZ got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePVZ.UpdatePVZMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePVZ.t.Fatal("No results are set for the UseCaseMock.UpdatePVZ")
		}
		return (*mm_results).err
	}
	if mmUpdatePVZ.funcUpdatePVZ != nil {
		return mmUpdatePVZ.funcUpdatePVZ(ctx, updatePVZRequest)
	}
	mmUpdatePVZ.t.Fatalf("Unexpected call to UseCaseMock.UpdatePVZ. %v %v", ctx, updatePVZRequest)
	return
}

// UpdatePVZAfterCounter returns a count of finished UseCaseMock.UpdatePVZ invocations
func (mmUpdatePVZ *UseCaseMock) UpdatePVZAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePVZ.afterUpdatePVZCounter)
}

// UpdatePVZBeforeCounter returns a count of UseCaseMock.UpdatePVZ invocations
func (mmUpdatePVZ *UseCaseMock) UpdatePVZBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePVZ.beforeUpdatePVZCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.UpdatePVZ.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePVZ *mUseCaseMockUpdatePVZ) Calls() []*UseCaseMockUpdatePVZParams {
	mmUpdatePVZ.mutex.RLock()

	argCopy := make([]*UseCaseMockUpdatePVZParams, len(mmUpdatePVZ.callArgs))
	copy(argCopy, mmUpdatePVZ.callArgs)

	mmUpdatePVZ.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePVZDone returns true if the count of the UpdatePVZ invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockUpdatePVZDone() bool {
	for _, e := range m.UpdatePVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePVZMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdatePVZCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePVZ != nil && mm_atomic.LoadUint64(&m.afterUpdatePVZCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdatePVZInspect logs each unmet expectation
func (m *UseCaseMock) MinimockUpdatePVZInspect() {
	for _, e := range m.UpdatePVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.UpdatePVZ with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePVZMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdatePVZCounter) < 1 {
		if m.UpdatePVZMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.UpdatePVZ")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.UpdatePVZ with params: %#v", *m.UpdatePVZMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePVZ != nil && mm_atomic.LoadUint64(&m.afterUpdatePVZCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.UpdatePVZ")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UseCaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreatePVZInspect()

			m.MinimockDeletePVZByIDInspect()

			m.MinimockGetPVZInspect()

			m.MinimockListPVZInspect()

			m.MinimockUpdatePVZInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UseCaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UseCaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreatePVZDone() &&
		m.MinimockDeletePVZByIDDone() &&
		m.MinimockGetPVZDone() &&
		m.MinimockListPVZDone() &&
		m.MinimockUpdatePVZDone()
}
