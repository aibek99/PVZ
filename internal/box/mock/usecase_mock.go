// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mock

import (
	"Homework-1/internal/model/abstract"
	boxModel "Homework-1/internal/model/box"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// UseCaseMock implements box.UseCase
type UseCaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateBox          func(ctx context.Context, request boxModel.Request) (i1 int64, err error)
	inspectFuncCreateBox   func(ctx context.Context, request boxModel.Request)
	afterCreateBoxCounter  uint64
	beforeCreateBoxCounter uint64
	CreateBoxMock          mUseCaseMockCreateBox

	funcDeleteBoxByID          func(ctx context.Context, boxID int64) (err error)
	inspectFuncDeleteBoxByID   func(ctx context.Context, boxID int64)
	afterDeleteBoxByIDCounter  uint64
	beforeDeleteBoxByIDCounter uint64
	DeleteBoxByIDMock          mUseCaseMockDeleteBoxByID

	funcGetBox          func(ctx context.Context, boxID int64) (a1 boxModel.AllResponse, err error)
	inspectFuncGetBox   func(ctx context.Context, boxID int64)
	afterGetBoxCounter  uint64
	beforeGetBoxCounter uint64
	GetBoxMock          mUseCaseMockGetBox

	funcListBoxes          func(ctx context.Context, boxPagination abstract.Page) (p1 abstract.PaginatedResponse[boxModel.AllResponse], err error)
	inspectFuncListBoxes   func(ctx context.Context, boxPagination abstract.Page)
	afterListBoxesCounter  uint64
	beforeListBoxesCounter uint64
	ListBoxesMock          mUseCaseMockListBoxes
}

// NewUseCaseMock returns a mock for box.UseCase
func NewUseCaseMock(t minimock.Tester) *UseCaseMock {
	m := &UseCaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateBoxMock = mUseCaseMockCreateBox{mock: m}
	m.CreateBoxMock.callArgs = []*UseCaseMockCreateBoxParams{}

	m.DeleteBoxByIDMock = mUseCaseMockDeleteBoxByID{mock: m}
	m.DeleteBoxByIDMock.callArgs = []*UseCaseMockDeleteBoxByIDParams{}

	m.GetBoxMock = mUseCaseMockGetBox{mock: m}
	m.GetBoxMock.callArgs = []*UseCaseMockGetBoxParams{}

	m.ListBoxesMock = mUseCaseMockListBoxes{mock: m}
	m.ListBoxesMock.callArgs = []*UseCaseMockListBoxesParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUseCaseMockCreateBox struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockCreateBoxExpectation
	expectations       []*UseCaseMockCreateBoxExpectation

	callArgs []*UseCaseMockCreateBoxParams
	mutex    sync.RWMutex
}

// UseCaseMockCreateBoxExpectation specifies expectation struct of the UseCase.CreateBox
type UseCaseMockCreateBoxExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockCreateBoxParams
	results *UseCaseMockCreateBoxResults
	Counter uint64
}

// UseCaseMockCreateBoxParams contains parameters of the UseCase.CreateBox
type UseCaseMockCreateBoxParams struct {
	ctx     context.Context
	request boxModel.Request
}

// UseCaseMockCreateBoxResults contains results of the UseCase.CreateBox
type UseCaseMockCreateBoxResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for UseCase.CreateBox
func (mmCreateBox *mUseCaseMockCreateBox) Expect(ctx context.Context, request boxModel.Request) *mUseCaseMockCreateBox {
	if mmCreateBox.mock.funcCreateBox != nil {
		mmCreateBox.mock.t.Fatalf("UseCaseMock.CreateBox mock is already set by Set")
	}

	if mmCreateBox.defaultExpectation == nil {
		mmCreateBox.defaultExpectation = &UseCaseMockCreateBoxExpectation{}
	}

	mmCreateBox.defaultExpectation.params = &UseCaseMockCreateBoxParams{ctx, request}
	for _, e := range mmCreateBox.expectations {
		if minimock.Equal(e.params, mmCreateBox.defaultExpectation.params) {
			mmCreateBox.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateBox.defaultExpectation.params)
		}
	}

	return mmCreateBox
}

// Inspect accepts an inspector function that has same arguments as the UseCase.CreateBox
func (mmCreateBox *mUseCaseMockCreateBox) Inspect(f func(ctx context.Context, request boxModel.Request)) *mUseCaseMockCreateBox {
	if mmCreateBox.mock.inspectFuncCreateBox != nil {
		mmCreateBox.mock.t.Fatalf("Inspect function is already set for UseCaseMock.CreateBox")
	}

	mmCreateBox.mock.inspectFuncCreateBox = f

	return mmCreateBox
}

// Return sets up results that will be returned by UseCase.CreateBox
func (mmCreateBox *mUseCaseMockCreateBox) Return(i1 int64, err error) *UseCaseMock {
	if mmCreateBox.mock.funcCreateBox != nil {
		mmCreateBox.mock.t.Fatalf("UseCaseMock.CreateBox mock is already set by Set")
	}

	if mmCreateBox.defaultExpectation == nil {
		mmCreateBox.defaultExpectation = &UseCaseMockCreateBoxExpectation{mock: mmCreateBox.mock}
	}
	mmCreateBox.defaultExpectation.results = &UseCaseMockCreateBoxResults{i1, err}
	return mmCreateBox.mock
}

// Set uses given function f to mock the UseCase.CreateBox method
func (mmCreateBox *mUseCaseMockCreateBox) Set(f func(ctx context.Context, request boxModel.Request) (i1 int64, err error)) *UseCaseMock {
	if mmCreateBox.defaultExpectation != nil {
		mmCreateBox.mock.t.Fatalf("Default expectation is already set for the UseCase.CreateBox method")
	}

	if len(mmCreateBox.expectations) > 0 {
		mmCreateBox.mock.t.Fatalf("Some expectations are already set for the UseCase.CreateBox method")
	}

	mmCreateBox.mock.funcCreateBox = f
	return mmCreateBox.mock
}

// When sets expectation for the UseCase.CreateBox which will trigger the result defined by the following
// Then helper
func (mmCreateBox *mUseCaseMockCreateBox) When(ctx context.Context, request boxModel.Request) *UseCaseMockCreateBoxExpectation {
	if mmCreateBox.mock.funcCreateBox != nil {
		mmCreateBox.mock.t.Fatalf("UseCaseMock.CreateBox mock is already set by Set")
	}

	expectation := &UseCaseMockCreateBoxExpectation{
		mock:   mmCreateBox.mock,
		params: &UseCaseMockCreateBoxParams{ctx, request},
	}
	mmCreateBox.expectations = append(mmCreateBox.expectations, expectation)
	return expectation
}

// Then sets up UseCase.CreateBox return parameters for the expectation previously defined by the When method
func (e *UseCaseMockCreateBoxExpectation) Then(i1 int64, err error) *UseCaseMock {
	e.results = &UseCaseMockCreateBoxResults{i1, err}
	return e.mock
}

// CreateBox implements box.UseCase
func (mmCreateBox *UseCaseMock) CreateBox(ctx context.Context, request boxModel.Request) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateBox.beforeCreateBoxCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateBox.afterCreateBoxCounter, 1)

	if mmCreateBox.inspectFuncCreateBox != nil {
		mmCreateBox.inspectFuncCreateBox(ctx, request)
	}

	mm_params := UseCaseMockCreateBoxParams{ctx, request}

	// Record call args
	mmCreateBox.CreateBoxMock.mutex.Lock()
	mmCreateBox.CreateBoxMock.callArgs = append(mmCreateBox.CreateBoxMock.callArgs, &mm_params)
	mmCreateBox.CreateBoxMock.mutex.Unlock()

	for _, e := range mmCreateBox.CreateBoxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateBox.CreateBoxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateBox.CreateBoxMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateBox.CreateBoxMock.defaultExpectation.params
		mm_got := UseCaseMockCreateBoxParams{ctx, request}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateBox.t.Errorf("UseCaseMock.CreateBox got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateBox.CreateBoxMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateBox.t.Fatal("No results are set for the UseCaseMock.CreateBox")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateBox.funcCreateBox != nil {
		return mmCreateBox.funcCreateBox(ctx, request)
	}
	mmCreateBox.t.Fatalf("Unexpected call to UseCaseMock.CreateBox. %v %v", ctx, request)
	return
}

// CreateBoxAfterCounter returns a count of finished UseCaseMock.CreateBox invocations
func (mmCreateBox *UseCaseMock) CreateBoxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBox.afterCreateBoxCounter)
}

// CreateBoxBeforeCounter returns a count of UseCaseMock.CreateBox invocations
func (mmCreateBox *UseCaseMock) CreateBoxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBox.beforeCreateBoxCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.CreateBox.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateBox *mUseCaseMockCreateBox) Calls() []*UseCaseMockCreateBoxParams {
	mmCreateBox.mutex.RLock()

	argCopy := make([]*UseCaseMockCreateBoxParams, len(mmCreateBox.callArgs))
	copy(argCopy, mmCreateBox.callArgs)

	mmCreateBox.mutex.RUnlock()

	return argCopy
}

// MinimockCreateBoxDone returns true if the count of the CreateBox invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockCreateBoxDone() bool {
	for _, e := range m.CreateBoxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBoxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateBoxCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBox != nil && mm_atomic.LoadUint64(&m.afterCreateBoxCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateBoxInspect logs each unmet expectation
func (m *UseCaseMock) MinimockCreateBoxInspect() {
	for _, e := range m.CreateBoxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.CreateBox with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBoxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateBoxCounter) < 1 {
		if m.CreateBoxMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.CreateBox")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.CreateBox with params: %#v", *m.CreateBoxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBox != nil && mm_atomic.LoadUint64(&m.afterCreateBoxCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.CreateBox")
	}
}

type mUseCaseMockDeleteBoxByID struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockDeleteBoxByIDExpectation
	expectations       []*UseCaseMockDeleteBoxByIDExpectation

	callArgs []*UseCaseMockDeleteBoxByIDParams
	mutex    sync.RWMutex
}

// UseCaseMockDeleteBoxByIDExpectation specifies expectation struct of the UseCase.DeleteBoxByID
type UseCaseMockDeleteBoxByIDExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockDeleteBoxByIDParams
	results *UseCaseMockDeleteBoxByIDResults
	Counter uint64
}

// UseCaseMockDeleteBoxByIDParams contains parameters of the UseCase.DeleteBoxByID
type UseCaseMockDeleteBoxByIDParams struct {
	ctx   context.Context
	boxID int64
}

// UseCaseMockDeleteBoxByIDResults contains results of the UseCase.DeleteBoxByID
type UseCaseMockDeleteBoxByIDResults struct {
	err error
}

// Expect sets up expected params for UseCase.DeleteBoxByID
func (mmDeleteBoxByID *mUseCaseMockDeleteBoxByID) Expect(ctx context.Context, boxID int64) *mUseCaseMockDeleteBoxByID {
	if mmDeleteBoxByID.mock.funcDeleteBoxByID != nil {
		mmDeleteBoxByID.mock.t.Fatalf("UseCaseMock.DeleteBoxByID mock is already set by Set")
	}

	if mmDeleteBoxByID.defaultExpectation == nil {
		mmDeleteBoxByID.defaultExpectation = &UseCaseMockDeleteBoxByIDExpectation{}
	}

	mmDeleteBoxByID.defaultExpectation.params = &UseCaseMockDeleteBoxByIDParams{ctx, boxID}
	for _, e := range mmDeleteBoxByID.expectations {
		if minimock.Equal(e.params, mmDeleteBoxByID.defaultExpectation.params) {
			mmDeleteBoxByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteBoxByID.defaultExpectation.params)
		}
	}

	return mmDeleteBoxByID
}

// Inspect accepts an inspector function that has same arguments as the UseCase.DeleteBoxByID
func (mmDeleteBoxByID *mUseCaseMockDeleteBoxByID) Inspect(f func(ctx context.Context, boxID int64)) *mUseCaseMockDeleteBoxByID {
	if mmDeleteBoxByID.mock.inspectFuncDeleteBoxByID != nil {
		mmDeleteBoxByID.mock.t.Fatalf("Inspect function is already set for UseCaseMock.DeleteBoxByID")
	}

	mmDeleteBoxByID.mock.inspectFuncDeleteBoxByID = f

	return mmDeleteBoxByID
}

// Return sets up results that will be returned by UseCase.DeleteBoxByID
func (mmDeleteBoxByID *mUseCaseMockDeleteBoxByID) Return(err error) *UseCaseMock {
	if mmDeleteBoxByID.mock.funcDeleteBoxByID != nil {
		mmDeleteBoxByID.mock.t.Fatalf("UseCaseMock.DeleteBoxByID mock is already set by Set")
	}

	if mmDeleteBoxByID.defaultExpectation == nil {
		mmDeleteBoxByID.defaultExpectation = &UseCaseMockDeleteBoxByIDExpectation{mock: mmDeleteBoxByID.mock}
	}
	mmDeleteBoxByID.defaultExpectation.results = &UseCaseMockDeleteBoxByIDResults{err}
	return mmDeleteBoxByID.mock
}

// Set uses given function f to mock the UseCase.DeleteBoxByID method
func (mmDeleteBoxByID *mUseCaseMockDeleteBoxByID) Set(f func(ctx context.Context, boxID int64) (err error)) *UseCaseMock {
	if mmDeleteBoxByID.defaultExpectation != nil {
		mmDeleteBoxByID.mock.t.Fatalf("Default expectation is already set for the UseCase.DeleteBoxByID method")
	}

	if len(mmDeleteBoxByID.expectations) > 0 {
		mmDeleteBoxByID.mock.t.Fatalf("Some expectations are already set for the UseCase.DeleteBoxByID method")
	}

	mmDeleteBoxByID.mock.funcDeleteBoxByID = f
	return mmDeleteBoxByID.mock
}

// When sets expectation for the UseCase.DeleteBoxByID which will trigger the result defined by the following
// Then helper
func (mmDeleteBoxByID *mUseCaseMockDeleteBoxByID) When(ctx context.Context, boxID int64) *UseCaseMockDeleteBoxByIDExpectation {
	if mmDeleteBoxByID.mock.funcDeleteBoxByID != nil {
		mmDeleteBoxByID.mock.t.Fatalf("UseCaseMock.DeleteBoxByID mock is already set by Set")
	}

	expectation := &UseCaseMockDeleteBoxByIDExpectation{
		mock:   mmDeleteBoxByID.mock,
		params: &UseCaseMockDeleteBoxByIDParams{ctx, boxID},
	}
	mmDeleteBoxByID.expectations = append(mmDeleteBoxByID.expectations, expectation)
	return expectation
}

// Then sets up UseCase.DeleteBoxByID return parameters for the expectation previously defined by the When method
func (e *UseCaseMockDeleteBoxByIDExpectation) Then(err error) *UseCaseMock {
	e.results = &UseCaseMockDeleteBoxByIDResults{err}
	return e.mock
}

// DeleteBoxByID implements box.UseCase
func (mmDeleteBoxByID *UseCaseMock) DeleteBoxByID(ctx context.Context, boxID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteBoxByID.beforeDeleteBoxByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteBoxByID.afterDeleteBoxByIDCounter, 1)

	if mmDeleteBoxByID.inspectFuncDeleteBoxByID != nil {
		mmDeleteBoxByID.inspectFuncDeleteBoxByID(ctx, boxID)
	}

	mm_params := UseCaseMockDeleteBoxByIDParams{ctx, boxID}

	// Record call args
	mmDeleteBoxByID.DeleteBoxByIDMock.mutex.Lock()
	mmDeleteBoxByID.DeleteBoxByIDMock.callArgs = append(mmDeleteBoxByID.DeleteBoxByIDMock.callArgs, &mm_params)
	mmDeleteBoxByID.DeleteBoxByIDMock.mutex.Unlock()

	for _, e := range mmDeleteBoxByID.DeleteBoxByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteBoxByID.DeleteBoxByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteBoxByID.DeleteBoxByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteBoxByID.DeleteBoxByIDMock.defaultExpectation.params
		mm_got := UseCaseMockDeleteBoxByIDParams{ctx, boxID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteBoxByID.t.Errorf("UseCaseMock.DeleteBoxByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteBoxByID.DeleteBoxByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteBoxByID.t.Fatal("No results are set for the UseCaseMock.DeleteBoxByID")
		}
		return (*mm_results).err
	}
	if mmDeleteBoxByID.funcDeleteBoxByID != nil {
		return mmDeleteBoxByID.funcDeleteBoxByID(ctx, boxID)
	}
	mmDeleteBoxByID.t.Fatalf("Unexpected call to UseCaseMock.DeleteBoxByID. %v %v", ctx, boxID)
	return
}

// DeleteBoxByIDAfterCounter returns a count of finished UseCaseMock.DeleteBoxByID invocations
func (mmDeleteBoxByID *UseCaseMock) DeleteBoxByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBoxByID.afterDeleteBoxByIDCounter)
}

// DeleteBoxByIDBeforeCounter returns a count of UseCaseMock.DeleteBoxByID invocations
func (mmDeleteBoxByID *UseCaseMock) DeleteBoxByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBoxByID.beforeDeleteBoxByIDCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.DeleteBoxByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteBoxByID *mUseCaseMockDeleteBoxByID) Calls() []*UseCaseMockDeleteBoxByIDParams {
	mmDeleteBoxByID.mutex.RLock()

	argCopy := make([]*UseCaseMockDeleteBoxByIDParams, len(mmDeleteBoxByID.callArgs))
	copy(argCopy, mmDeleteBoxByID.callArgs)

	mmDeleteBoxByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteBoxByIDDone returns true if the count of the DeleteBoxByID invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockDeleteBoxByIDDone() bool {
	for _, e := range m.DeleteBoxByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteBoxByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteBoxByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteBoxByID != nil && mm_atomic.LoadUint64(&m.afterDeleteBoxByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteBoxByIDInspect logs each unmet expectation
func (m *UseCaseMock) MinimockDeleteBoxByIDInspect() {
	for _, e := range m.DeleteBoxByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.DeleteBoxByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteBoxByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteBoxByIDCounter) < 1 {
		if m.DeleteBoxByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.DeleteBoxByID")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.DeleteBoxByID with params: %#v", *m.DeleteBoxByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteBoxByID != nil && mm_atomic.LoadUint64(&m.afterDeleteBoxByIDCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.DeleteBoxByID")
	}
}

type mUseCaseMockGetBox struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockGetBoxExpectation
	expectations       []*UseCaseMockGetBoxExpectation

	callArgs []*UseCaseMockGetBoxParams
	mutex    sync.RWMutex
}

// UseCaseMockGetBoxExpectation specifies expectation struct of the UseCase.GetBox
type UseCaseMockGetBoxExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockGetBoxParams
	results *UseCaseMockGetBoxResults
	Counter uint64
}

// UseCaseMockGetBoxParams contains parameters of the UseCase.GetBox
type UseCaseMockGetBoxParams struct {
	ctx   context.Context
	boxID int64
}

// UseCaseMockGetBoxResults contains results of the UseCase.GetBox
type UseCaseMockGetBoxResults struct {
	a1  boxModel.AllResponse
	err error
}

// Expect sets up expected params for UseCase.GetBox
func (mmGetBox *mUseCaseMockGetBox) Expect(ctx context.Context, boxID int64) *mUseCaseMockGetBox {
	if mmGetBox.mock.funcGetBox != nil {
		mmGetBox.mock.t.Fatalf("UseCaseMock.GetBox mock is already set by Set")
	}

	if mmGetBox.defaultExpectation == nil {
		mmGetBox.defaultExpectation = &UseCaseMockGetBoxExpectation{}
	}

	mmGetBox.defaultExpectation.params = &UseCaseMockGetBoxParams{ctx, boxID}
	for _, e := range mmGetBox.expectations {
		if minimock.Equal(e.params, mmGetBox.defaultExpectation.params) {
			mmGetBox.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBox.defaultExpectation.params)
		}
	}

	return mmGetBox
}

// Inspect accepts an inspector function that has same arguments as the UseCase.GetBox
func (mmGetBox *mUseCaseMockGetBox) Inspect(f func(ctx context.Context, boxID int64)) *mUseCaseMockGetBox {
	if mmGetBox.mock.inspectFuncGetBox != nil {
		mmGetBox.mock.t.Fatalf("Inspect function is already set for UseCaseMock.GetBox")
	}

	mmGetBox.mock.inspectFuncGetBox = f

	return mmGetBox
}

// Return sets up results that will be returned by UseCase.GetBox
func (mmGetBox *mUseCaseMockGetBox) Return(a1 boxModel.AllResponse, err error) *UseCaseMock {
	if mmGetBox.mock.funcGetBox != nil {
		mmGetBox.mock.t.Fatalf("UseCaseMock.GetBox mock is already set by Set")
	}

	if mmGetBox.defaultExpectation == nil {
		mmGetBox.defaultExpectation = &UseCaseMockGetBoxExpectation{mock: mmGetBox.mock}
	}
	mmGetBox.defaultExpectation.results = &UseCaseMockGetBoxResults{a1, err}
	return mmGetBox.mock
}

// Set uses given function f to mock the UseCase.GetBox method
func (mmGetBox *mUseCaseMockGetBox) Set(f func(ctx context.Context, boxID int64) (a1 boxModel.AllResponse, err error)) *UseCaseMock {
	if mmGetBox.defaultExpectation != nil {
		mmGetBox.mock.t.Fatalf("Default expectation is already set for the UseCase.GetBox method")
	}

	if len(mmGetBox.expectations) > 0 {
		mmGetBox.mock.t.Fatalf("Some expectations are already set for the UseCase.GetBox method")
	}

	mmGetBox.mock.funcGetBox = f
	return mmGetBox.mock
}

// When sets expectation for the UseCase.GetBox which will trigger the result defined by the following
// Then helper
func (mmGetBox *mUseCaseMockGetBox) When(ctx context.Context, boxID int64) *UseCaseMockGetBoxExpectation {
	if mmGetBox.mock.funcGetBox != nil {
		mmGetBox.mock.t.Fatalf("UseCaseMock.GetBox mock is already set by Set")
	}

	expectation := &UseCaseMockGetBoxExpectation{
		mock:   mmGetBox.mock,
		params: &UseCaseMockGetBoxParams{ctx, boxID},
	}
	mmGetBox.expectations = append(mmGetBox.expectations, expectation)
	return expectation
}

// Then sets up UseCase.GetBox return parameters for the expectation previously defined by the When method
func (e *UseCaseMockGetBoxExpectation) Then(a1 boxModel.AllResponse, err error) *UseCaseMock {
	e.results = &UseCaseMockGetBoxResults{a1, err}
	return e.mock
}

// GetBox implements box.UseCase
func (mmGetBox *UseCaseMock) GetBox(ctx context.Context, boxID int64) (a1 boxModel.AllResponse, err error) {
	mm_atomic.AddUint64(&mmGetBox.beforeGetBoxCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBox.afterGetBoxCounter, 1)

	if mmGetBox.inspectFuncGetBox != nil {
		mmGetBox.inspectFuncGetBox(ctx, boxID)
	}

	mm_params := UseCaseMockGetBoxParams{ctx, boxID}

	// Record call args
	mmGetBox.GetBoxMock.mutex.Lock()
	mmGetBox.GetBoxMock.callArgs = append(mmGetBox.GetBoxMock.callArgs, &mm_params)
	mmGetBox.GetBoxMock.mutex.Unlock()

	for _, e := range mmGetBox.GetBoxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1, e.results.err
		}
	}

	if mmGetBox.GetBoxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBox.GetBoxMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBox.GetBoxMock.defaultExpectation.params
		mm_got := UseCaseMockGetBoxParams{ctx, boxID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBox.t.Errorf("UseCaseMock.GetBox got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBox.GetBoxMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBox.t.Fatal("No results are set for the UseCaseMock.GetBox")
		}
		return (*mm_results).a1, (*mm_results).err
	}
	if mmGetBox.funcGetBox != nil {
		return mmGetBox.funcGetBox(ctx, boxID)
	}
	mmGetBox.t.Fatalf("Unexpected call to UseCaseMock.GetBox. %v %v", ctx, boxID)
	return
}

// GetBoxAfterCounter returns a count of finished UseCaseMock.GetBox invocations
func (mmGetBox *UseCaseMock) GetBoxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBox.afterGetBoxCounter)
}

// GetBoxBeforeCounter returns a count of UseCaseMock.GetBox invocations
func (mmGetBox *UseCaseMock) GetBoxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBox.beforeGetBoxCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.GetBox.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBox *mUseCaseMockGetBox) Calls() []*UseCaseMockGetBoxParams {
	mmGetBox.mutex.RLock()

	argCopy := make([]*UseCaseMockGetBoxParams, len(mmGetBox.callArgs))
	copy(argCopy, mmGetBox.callArgs)

	mmGetBox.mutex.RUnlock()

	return argCopy
}

// MinimockGetBoxDone returns true if the count of the GetBox invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockGetBoxDone() bool {
	for _, e := range m.GetBoxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBoxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBoxCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBox != nil && mm_atomic.LoadUint64(&m.afterGetBoxCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetBoxInspect logs each unmet expectation
func (m *UseCaseMock) MinimockGetBoxInspect() {
	for _, e := range m.GetBoxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.GetBox with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBoxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBoxCounter) < 1 {
		if m.GetBoxMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.GetBox")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.GetBox with params: %#v", *m.GetBoxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBox != nil && mm_atomic.LoadUint64(&m.afterGetBoxCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.GetBox")
	}
}

type mUseCaseMockListBoxes struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockListBoxesExpectation
	expectations       []*UseCaseMockListBoxesExpectation

	callArgs []*UseCaseMockListBoxesParams
	mutex    sync.RWMutex
}

// UseCaseMockListBoxesExpectation specifies expectation struct of the UseCase.ListBoxes
type UseCaseMockListBoxesExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockListBoxesParams
	results *UseCaseMockListBoxesResults
	Counter uint64
}

// UseCaseMockListBoxesParams contains parameters of the UseCase.ListBoxes
type UseCaseMockListBoxesParams struct {
	ctx           context.Context
	boxPagination abstract.Page
}

// UseCaseMockListBoxesResults contains results of the UseCase.ListBoxes
type UseCaseMockListBoxesResults struct {
	p1  abstract.PaginatedResponse[boxModel.AllResponse]
	err error
}

// Expect sets up expected params for UseCase.ListBoxes
func (mmListBoxes *mUseCaseMockListBoxes) Expect(ctx context.Context, boxPagination abstract.Page) *mUseCaseMockListBoxes {
	if mmListBoxes.mock.funcListBoxes != nil {
		mmListBoxes.mock.t.Fatalf("UseCaseMock.ListBoxes mock is already set by Set")
	}

	if mmListBoxes.defaultExpectation == nil {
		mmListBoxes.defaultExpectation = &UseCaseMockListBoxesExpectation{}
	}

	mmListBoxes.defaultExpectation.params = &UseCaseMockListBoxesParams{ctx, boxPagination}
	for _, e := range mmListBoxes.expectations {
		if minimock.Equal(e.params, mmListBoxes.defaultExpectation.params) {
			mmListBoxes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListBoxes.defaultExpectation.params)
		}
	}

	return mmListBoxes
}

// Inspect accepts an inspector function that has same arguments as the UseCase.ListBoxes
func (mmListBoxes *mUseCaseMockListBoxes) Inspect(f func(ctx context.Context, boxPagination abstract.Page)) *mUseCaseMockListBoxes {
	if mmListBoxes.mock.inspectFuncListBoxes != nil {
		mmListBoxes.mock.t.Fatalf("Inspect function is already set for UseCaseMock.ListBoxes")
	}

	mmListBoxes.mock.inspectFuncListBoxes = f

	return mmListBoxes
}

// Return sets up results that will be returned by UseCase.ListBoxes
func (mmListBoxes *mUseCaseMockListBoxes) Return(p1 abstract.PaginatedResponse[boxModel.AllResponse], err error) *UseCaseMock {
	if mmListBoxes.mock.funcListBoxes != nil {
		mmListBoxes.mock.t.Fatalf("UseCaseMock.ListBoxes mock is already set by Set")
	}

	if mmListBoxes.defaultExpectation == nil {
		mmListBoxes.defaultExpectation = &UseCaseMockListBoxesExpectation{mock: mmListBoxes.mock}
	}
	mmListBoxes.defaultExpectation.results = &UseCaseMockListBoxesResults{p1, err}
	return mmListBoxes.mock
}

// Set uses given function f to mock the UseCase.ListBoxes method
func (mmListBoxes *mUseCaseMockListBoxes) Set(f func(ctx context.Context, boxPagination abstract.Page) (p1 abstract.PaginatedResponse[boxModel.AllResponse], err error)) *UseCaseMock {
	if mmListBoxes.defaultExpectation != nil {
		mmListBoxes.mock.t.Fatalf("Default expectation is already set for the UseCase.ListBoxes method")
	}

	if len(mmListBoxes.expectations) > 0 {
		mmListBoxes.mock.t.Fatalf("Some expectations are already set for the UseCase.ListBoxes method")
	}

	mmListBoxes.mock.funcListBoxes = f
	return mmListBoxes.mock
}

// When sets expectation for the UseCase.ListBoxes which will trigger the result defined by the following
// Then helper
func (mmListBoxes *mUseCaseMockListBoxes) When(ctx context.Context, boxPagination abstract.Page) *UseCaseMockListBoxesExpectation {
	if mmListBoxes.mock.funcListBoxes != nil {
		mmListBoxes.mock.t.Fatalf("UseCaseMock.ListBoxes mock is already set by Set")
	}

	expectation := &UseCaseMockListBoxesExpectation{
		mock:   mmListBoxes.mock,
		params: &UseCaseMockListBoxesParams{ctx, boxPagination},
	}
	mmListBoxes.expectations = append(mmListBoxes.expectations, expectation)
	return expectation
}

// Then sets up UseCase.ListBoxes return parameters for the expectation previously defined by the When method
func (e *UseCaseMockListBoxesExpectation) Then(p1 abstract.PaginatedResponse[boxModel.AllResponse], err error) *UseCaseMock {
	e.results = &UseCaseMockListBoxesResults{p1, err}
	return e.mock
}

// ListBoxes implements box.UseCase
func (mmListBoxes *UseCaseMock) ListBoxes(ctx context.Context, boxPagination abstract.Page) (p1 abstract.PaginatedResponse[boxModel.AllResponse], err error) {
	mm_atomic.AddUint64(&mmListBoxes.beforeListBoxesCounter, 1)
	defer mm_atomic.AddUint64(&mmListBoxes.afterListBoxesCounter, 1)

	if mmListBoxes.inspectFuncListBoxes != nil {
		mmListBoxes.inspectFuncListBoxes(ctx, boxPagination)
	}

	mm_params := UseCaseMockListBoxesParams{ctx, boxPagination}

	// Record call args
	mmListBoxes.ListBoxesMock.mutex.Lock()
	mmListBoxes.ListBoxesMock.callArgs = append(mmListBoxes.ListBoxesMock.callArgs, &mm_params)
	mmListBoxes.ListBoxesMock.mutex.Unlock()

	for _, e := range mmListBoxes.ListBoxesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmListBoxes.ListBoxesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListBoxes.ListBoxesMock.defaultExpectation.Counter, 1)
		mm_want := mmListBoxes.ListBoxesMock.defaultExpectation.params
		mm_got := UseCaseMockListBoxesParams{ctx, boxPagination}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListBoxes.t.Errorf("UseCaseMock.ListBoxes got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListBoxes.ListBoxesMock.defaultExpectation.results
		if mm_results == nil {
			mmListBoxes.t.Fatal("No results are set for the UseCaseMock.ListBoxes")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmListBoxes.funcListBoxes != nil {
		return mmListBoxes.funcListBoxes(ctx, boxPagination)
	}
	mmListBoxes.t.Fatalf("Unexpected call to UseCaseMock.ListBoxes. %v %v", ctx, boxPagination)
	return
}

// ListBoxesAfterCounter returns a count of finished UseCaseMock.ListBoxes invocations
func (mmListBoxes *UseCaseMock) ListBoxesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListBoxes.afterListBoxesCounter)
}

// ListBoxesBeforeCounter returns a count of UseCaseMock.ListBoxes invocations
func (mmListBoxes *UseCaseMock) ListBoxesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListBoxes.beforeListBoxesCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.ListBoxes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListBoxes *mUseCaseMockListBoxes) Calls() []*UseCaseMockListBoxesParams {
	mmListBoxes.mutex.RLock()

	argCopy := make([]*UseCaseMockListBoxesParams, len(mmListBoxes.callArgs))
	copy(argCopy, mmListBoxes.callArgs)

	mmListBoxes.mutex.RUnlock()

	return argCopy
}

// MinimockListBoxesDone returns true if the count of the ListBoxes invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockListBoxesDone() bool {
	for _, e := range m.ListBoxesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListBoxesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListBoxesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListBoxes != nil && mm_atomic.LoadUint64(&m.afterListBoxesCounter) < 1 {
		return false
	}
	return true
}

// MinimockListBoxesInspect logs each unmet expectation
func (m *UseCaseMock) MinimockListBoxesInspect() {
	for _, e := range m.ListBoxesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.ListBoxes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListBoxesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListBoxesCounter) < 1 {
		if m.ListBoxesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.ListBoxes")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.ListBoxes with params: %#v", *m.ListBoxesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListBoxes != nil && mm_atomic.LoadUint64(&m.afterListBoxesCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.ListBoxes")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UseCaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateBoxInspect()

			m.MinimockDeleteBoxByIDInspect()

			m.MinimockGetBoxInspect()

			m.MinimockListBoxesInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UseCaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UseCaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateBoxDone() &&
		m.MinimockDeleteBoxByIDDone() &&
		m.MinimockGetBoxDone() &&
		m.MinimockListBoxesDone()
}
