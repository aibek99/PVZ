// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mock

import (
	"Homework-1/internal/model/abstract"
	orderModel "Homework-1/internal/model/order"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// UseCaseMock implements order.UseCase
type UseCaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateReceiveOrder          func(ctx context.Context, request orderModel.Request) (err error)
	inspectFuncCreateReceiveOrder   func(ctx context.Context, request orderModel.Request)
	afterCreateReceiveOrderCounter  uint64
	beforeCreateReceiveOrderCounter uint64
	CreateReceiveOrderMock          mUseCaseMockCreateReceiveOrder

	funcDeleteReturnedOrder          func(ctx context.Context, orderID int64) (err error)
	inspectFuncDeleteReturnedOrder   func(ctx context.Context, orderID int64)
	afterDeleteReturnedOrderCounter  uint64
	beforeDeleteReturnedOrderCounter uint64
	DeleteReturnedOrderMock          mUseCaseMockDeleteReturnedOrder

	funcIssueOrders          func(ctx context.Context, request orderModel.RequestOrderIDs) (f1 float64, err error)
	inspectFuncIssueOrders   func(ctx context.Context, request orderModel.RequestOrderIDs)
	afterIssueOrdersCounter  uint64
	beforeIssueOrdersCounter uint64
	IssueOrdersMock          mUseCaseMockIssueOrders

	funcOrderList          func(ctx context.Context, request abstract.Page) (p1 abstract.PaginatedResponse[orderModel.AllResponse], err error)
	inspectFuncOrderList   func(ctx context.Context, request abstract.Page)
	afterOrderListCounter  uint64
	beforeOrderListCounter uint64
	OrderListMock          mUseCaseMockOrderList

	funcReturnedOrders          func(ctx context.Context, request abstract.Page) (p1 abstract.PaginatedResponse[orderModel.ReturnedResponse], err error)
	inspectFuncReturnedOrders   func(ctx context.Context, request abstract.Page)
	afterReturnedOrdersCounter  uint64
	beforeReturnedOrdersCounter uint64
	ReturnedOrdersMock          mUseCaseMockReturnedOrders

	funcUniqueClientsList          func(ctx context.Context, request abstract.Page) (p1 abstract.PaginatedResponse[orderModel.ListUniqueClients], err error)
	inspectFuncUniqueClientsList   func(ctx context.Context, request abstract.Page)
	afterUniqueClientsListCounter  uint64
	beforeUniqueClientsListCounter uint64
	UniqueClientsListMock          mUseCaseMockUniqueClientsList

	funcUpdateAcceptOrder          func(ctx context.Context, request orderModel.RequestWithClientID) (err error)
	inspectFuncUpdateAcceptOrder   func(ctx context.Context, request orderModel.RequestWithClientID)
	afterUpdateAcceptOrderCounter  uint64
	beforeUpdateAcceptOrderCounter uint64
	UpdateAcceptOrderMock          mUseCaseMockUpdateAcceptOrder
}

// NewUseCaseMock returns a mock for order.UseCase
func NewUseCaseMock(t minimock.Tester) *UseCaseMock {
	m := &UseCaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateReceiveOrderMock = mUseCaseMockCreateReceiveOrder{mock: m}
	m.CreateReceiveOrderMock.callArgs = []*UseCaseMockCreateReceiveOrderParams{}

	m.DeleteReturnedOrderMock = mUseCaseMockDeleteReturnedOrder{mock: m}
	m.DeleteReturnedOrderMock.callArgs = []*UseCaseMockDeleteReturnedOrderParams{}

	m.IssueOrdersMock = mUseCaseMockIssueOrders{mock: m}
	m.IssueOrdersMock.callArgs = []*UseCaseMockIssueOrdersParams{}

	m.OrderListMock = mUseCaseMockOrderList{mock: m}
	m.OrderListMock.callArgs = []*UseCaseMockOrderListParams{}

	m.ReturnedOrdersMock = mUseCaseMockReturnedOrders{mock: m}
	m.ReturnedOrdersMock.callArgs = []*UseCaseMockReturnedOrdersParams{}

	m.UniqueClientsListMock = mUseCaseMockUniqueClientsList{mock: m}
	m.UniqueClientsListMock.callArgs = []*UseCaseMockUniqueClientsListParams{}

	m.UpdateAcceptOrderMock = mUseCaseMockUpdateAcceptOrder{mock: m}
	m.UpdateAcceptOrderMock.callArgs = []*UseCaseMockUpdateAcceptOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUseCaseMockCreateReceiveOrder struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockCreateReceiveOrderExpectation
	expectations       []*UseCaseMockCreateReceiveOrderExpectation

	callArgs []*UseCaseMockCreateReceiveOrderParams
	mutex    sync.RWMutex
}

// UseCaseMockCreateReceiveOrderExpectation specifies expectation struct of the UseCase.CreateReceiveOrder
type UseCaseMockCreateReceiveOrderExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockCreateReceiveOrderParams
	results *UseCaseMockCreateReceiveOrderResults
	Counter uint64
}

// UseCaseMockCreateReceiveOrderParams contains parameters of the UseCase.CreateReceiveOrder
type UseCaseMockCreateReceiveOrderParams struct {
	ctx     context.Context
	request orderModel.Request
}

// UseCaseMockCreateReceiveOrderResults contains results of the UseCase.CreateReceiveOrder
type UseCaseMockCreateReceiveOrderResults struct {
	err error
}

// Expect sets up expected params for UseCase.CreateReceiveOrder
func (mmCreateReceiveOrder *mUseCaseMockCreateReceiveOrder) Expect(ctx context.Context, request orderModel.Request) *mUseCaseMockCreateReceiveOrder {
	if mmCreateReceiveOrder.mock.funcCreateReceiveOrder != nil {
		mmCreateReceiveOrder.mock.t.Fatalf("UseCaseMock.CreateReceiveOrder mock is already set by Set")
	}

	if mmCreateReceiveOrder.defaultExpectation == nil {
		mmCreateReceiveOrder.defaultExpectation = &UseCaseMockCreateReceiveOrderExpectation{}
	}

	mmCreateReceiveOrder.defaultExpectation.params = &UseCaseMockCreateReceiveOrderParams{ctx, request}
	for _, e := range mmCreateReceiveOrder.expectations {
		if minimock.Equal(e.params, mmCreateReceiveOrder.defaultExpectation.params) {
			mmCreateReceiveOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateReceiveOrder.defaultExpectation.params)
		}
	}

	return mmCreateReceiveOrder
}

// Inspect accepts an inspector function that has same arguments as the UseCase.CreateReceiveOrder
func (mmCreateReceiveOrder *mUseCaseMockCreateReceiveOrder) Inspect(f func(ctx context.Context, request orderModel.Request)) *mUseCaseMockCreateReceiveOrder {
	if mmCreateReceiveOrder.mock.inspectFuncCreateReceiveOrder != nil {
		mmCreateReceiveOrder.mock.t.Fatalf("Inspect function is already set for UseCaseMock.CreateReceiveOrder")
	}

	mmCreateReceiveOrder.mock.inspectFuncCreateReceiveOrder = f

	return mmCreateReceiveOrder
}

// Return sets up results that will be returned by UseCase.CreateReceiveOrder
func (mmCreateReceiveOrder *mUseCaseMockCreateReceiveOrder) Return(err error) *UseCaseMock {
	if mmCreateReceiveOrder.mock.funcCreateReceiveOrder != nil {
		mmCreateReceiveOrder.mock.t.Fatalf("UseCaseMock.CreateReceiveOrder mock is already set by Set")
	}

	if mmCreateReceiveOrder.defaultExpectation == nil {
		mmCreateReceiveOrder.defaultExpectation = &UseCaseMockCreateReceiveOrderExpectation{mock: mmCreateReceiveOrder.mock}
	}
	mmCreateReceiveOrder.defaultExpectation.results = &UseCaseMockCreateReceiveOrderResults{err}
	return mmCreateReceiveOrder.mock
}

// Set uses given function f to mock the UseCase.CreateReceiveOrder method
func (mmCreateReceiveOrder *mUseCaseMockCreateReceiveOrder) Set(f func(ctx context.Context, request orderModel.Request) (err error)) *UseCaseMock {
	if mmCreateReceiveOrder.defaultExpectation != nil {
		mmCreateReceiveOrder.mock.t.Fatalf("Default expectation is already set for the UseCase.CreateReceiveOrder method")
	}

	if len(mmCreateReceiveOrder.expectations) > 0 {
		mmCreateReceiveOrder.mock.t.Fatalf("Some expectations are already set for the UseCase.CreateReceiveOrder method")
	}

	mmCreateReceiveOrder.mock.funcCreateReceiveOrder = f
	return mmCreateReceiveOrder.mock
}

// When sets expectation for the UseCase.CreateReceiveOrder which will trigger the result defined by the following
// Then helper
func (mmCreateReceiveOrder *mUseCaseMockCreateReceiveOrder) When(ctx context.Context, request orderModel.Request) *UseCaseMockCreateReceiveOrderExpectation {
	if mmCreateReceiveOrder.mock.funcCreateReceiveOrder != nil {
		mmCreateReceiveOrder.mock.t.Fatalf("UseCaseMock.CreateReceiveOrder mock is already set by Set")
	}

	expectation := &UseCaseMockCreateReceiveOrderExpectation{
		mock:   mmCreateReceiveOrder.mock,
		params: &UseCaseMockCreateReceiveOrderParams{ctx, request},
	}
	mmCreateReceiveOrder.expectations = append(mmCreateReceiveOrder.expectations, expectation)
	return expectation
}

// Then sets up UseCase.CreateReceiveOrder return parameters for the expectation previously defined by the When method
func (e *UseCaseMockCreateReceiveOrderExpectation) Then(err error) *UseCaseMock {
	e.results = &UseCaseMockCreateReceiveOrderResults{err}
	return e.mock
}

// CreateReceiveOrder implements order.UseCase
func (mmCreateReceiveOrder *UseCaseMock) CreateReceiveOrder(ctx context.Context, request orderModel.Request) (err error) {
	mm_atomic.AddUint64(&mmCreateReceiveOrder.beforeCreateReceiveOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateReceiveOrder.afterCreateReceiveOrderCounter, 1)

	if mmCreateReceiveOrder.inspectFuncCreateReceiveOrder != nil {
		mmCreateReceiveOrder.inspectFuncCreateReceiveOrder(ctx, request)
	}

	mm_params := UseCaseMockCreateReceiveOrderParams{ctx, request}

	// Record call args
	mmCreateReceiveOrder.CreateReceiveOrderMock.mutex.Lock()
	mmCreateReceiveOrder.CreateReceiveOrderMock.callArgs = append(mmCreateReceiveOrder.CreateReceiveOrderMock.callArgs, &mm_params)
	mmCreateReceiveOrder.CreateReceiveOrderMock.mutex.Unlock()

	for _, e := range mmCreateReceiveOrder.CreateReceiveOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateReceiveOrder.CreateReceiveOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateReceiveOrder.CreateReceiveOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateReceiveOrder.CreateReceiveOrderMock.defaultExpectation.params
		mm_got := UseCaseMockCreateReceiveOrderParams{ctx, request}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateReceiveOrder.t.Errorf("UseCaseMock.CreateReceiveOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateReceiveOrder.CreateReceiveOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateReceiveOrder.t.Fatal("No results are set for the UseCaseMock.CreateReceiveOrder")
		}
		return (*mm_results).err
	}
	if mmCreateReceiveOrder.funcCreateReceiveOrder != nil {
		return mmCreateReceiveOrder.funcCreateReceiveOrder(ctx, request)
	}
	mmCreateReceiveOrder.t.Fatalf("Unexpected call to UseCaseMock.CreateReceiveOrder. %v %v", ctx, request)
	return
}

// CreateReceiveOrderAfterCounter returns a count of finished UseCaseMock.CreateReceiveOrder invocations
func (mmCreateReceiveOrder *UseCaseMock) CreateReceiveOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReceiveOrder.afterCreateReceiveOrderCounter)
}

// CreateReceiveOrderBeforeCounter returns a count of UseCaseMock.CreateReceiveOrder invocations
func (mmCreateReceiveOrder *UseCaseMock) CreateReceiveOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReceiveOrder.beforeCreateReceiveOrderCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.CreateReceiveOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateReceiveOrder *mUseCaseMockCreateReceiveOrder) Calls() []*UseCaseMockCreateReceiveOrderParams {
	mmCreateReceiveOrder.mutex.RLock()

	argCopy := make([]*UseCaseMockCreateReceiveOrderParams, len(mmCreateReceiveOrder.callArgs))
	copy(argCopy, mmCreateReceiveOrder.callArgs)

	mmCreateReceiveOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateReceiveOrderDone returns true if the count of the CreateReceiveOrder invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockCreateReceiveOrderDone() bool {
	for _, e := range m.CreateReceiveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateReceiveOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateReceiveOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateReceiveOrder != nil && mm_atomic.LoadUint64(&m.afterCreateReceiveOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateReceiveOrderInspect logs each unmet expectation
func (m *UseCaseMock) MinimockCreateReceiveOrderInspect() {
	for _, e := range m.CreateReceiveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.CreateReceiveOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateReceiveOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateReceiveOrderCounter) < 1 {
		if m.CreateReceiveOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.CreateReceiveOrder")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.CreateReceiveOrder with params: %#v", *m.CreateReceiveOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateReceiveOrder != nil && mm_atomic.LoadUint64(&m.afterCreateReceiveOrderCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.CreateReceiveOrder")
	}
}

type mUseCaseMockDeleteReturnedOrder struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockDeleteReturnedOrderExpectation
	expectations       []*UseCaseMockDeleteReturnedOrderExpectation

	callArgs []*UseCaseMockDeleteReturnedOrderParams
	mutex    sync.RWMutex
}

// UseCaseMockDeleteReturnedOrderExpectation specifies expectation struct of the UseCase.DeleteReturnedOrder
type UseCaseMockDeleteReturnedOrderExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockDeleteReturnedOrderParams
	results *UseCaseMockDeleteReturnedOrderResults
	Counter uint64
}

// UseCaseMockDeleteReturnedOrderParams contains parameters of the UseCase.DeleteReturnedOrder
type UseCaseMockDeleteReturnedOrderParams struct {
	ctx     context.Context
	orderID int64
}

// UseCaseMockDeleteReturnedOrderResults contains results of the UseCase.DeleteReturnedOrder
type UseCaseMockDeleteReturnedOrderResults struct {
	err error
}

// Expect sets up expected params for UseCase.DeleteReturnedOrder
func (mmDeleteReturnedOrder *mUseCaseMockDeleteReturnedOrder) Expect(ctx context.Context, orderID int64) *mUseCaseMockDeleteReturnedOrder {
	if mmDeleteReturnedOrder.mock.funcDeleteReturnedOrder != nil {
		mmDeleteReturnedOrder.mock.t.Fatalf("UseCaseMock.DeleteReturnedOrder mock is already set by Set")
	}

	if mmDeleteReturnedOrder.defaultExpectation == nil {
		mmDeleteReturnedOrder.defaultExpectation = &UseCaseMockDeleteReturnedOrderExpectation{}
	}

	mmDeleteReturnedOrder.defaultExpectation.params = &UseCaseMockDeleteReturnedOrderParams{ctx, orderID}
	for _, e := range mmDeleteReturnedOrder.expectations {
		if minimock.Equal(e.params, mmDeleteReturnedOrder.defaultExpectation.params) {
			mmDeleteReturnedOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteReturnedOrder.defaultExpectation.params)
		}
	}

	return mmDeleteReturnedOrder
}

// Inspect accepts an inspector function that has same arguments as the UseCase.DeleteReturnedOrder
func (mmDeleteReturnedOrder *mUseCaseMockDeleteReturnedOrder) Inspect(f func(ctx context.Context, orderID int64)) *mUseCaseMockDeleteReturnedOrder {
	if mmDeleteReturnedOrder.mock.inspectFuncDeleteReturnedOrder != nil {
		mmDeleteReturnedOrder.mock.t.Fatalf("Inspect function is already set for UseCaseMock.DeleteReturnedOrder")
	}

	mmDeleteReturnedOrder.mock.inspectFuncDeleteReturnedOrder = f

	return mmDeleteReturnedOrder
}

// Return sets up results that will be returned by UseCase.DeleteReturnedOrder
func (mmDeleteReturnedOrder *mUseCaseMockDeleteReturnedOrder) Return(err error) *UseCaseMock {
	if mmDeleteReturnedOrder.mock.funcDeleteReturnedOrder != nil {
		mmDeleteReturnedOrder.mock.t.Fatalf("UseCaseMock.DeleteReturnedOrder mock is already set by Set")
	}

	if mmDeleteReturnedOrder.defaultExpectation == nil {
		mmDeleteReturnedOrder.defaultExpectation = &UseCaseMockDeleteReturnedOrderExpectation{mock: mmDeleteReturnedOrder.mock}
	}
	mmDeleteReturnedOrder.defaultExpectation.results = &UseCaseMockDeleteReturnedOrderResults{err}
	return mmDeleteReturnedOrder.mock
}

// Set uses given function f to mock the UseCase.DeleteReturnedOrder method
func (mmDeleteReturnedOrder *mUseCaseMockDeleteReturnedOrder) Set(f func(ctx context.Context, orderID int64) (err error)) *UseCaseMock {
	if mmDeleteReturnedOrder.defaultExpectation != nil {
		mmDeleteReturnedOrder.mock.t.Fatalf("Default expectation is already set for the UseCase.DeleteReturnedOrder method")
	}

	if len(mmDeleteReturnedOrder.expectations) > 0 {
		mmDeleteReturnedOrder.mock.t.Fatalf("Some expectations are already set for the UseCase.DeleteReturnedOrder method")
	}

	mmDeleteReturnedOrder.mock.funcDeleteReturnedOrder = f
	return mmDeleteReturnedOrder.mock
}

// When sets expectation for the UseCase.DeleteReturnedOrder which will trigger the result defined by the following
// Then helper
func (mmDeleteReturnedOrder *mUseCaseMockDeleteReturnedOrder) When(ctx context.Context, orderID int64) *UseCaseMockDeleteReturnedOrderExpectation {
	if mmDeleteReturnedOrder.mock.funcDeleteReturnedOrder != nil {
		mmDeleteReturnedOrder.mock.t.Fatalf("UseCaseMock.DeleteReturnedOrder mock is already set by Set")
	}

	expectation := &UseCaseMockDeleteReturnedOrderExpectation{
		mock:   mmDeleteReturnedOrder.mock,
		params: &UseCaseMockDeleteReturnedOrderParams{ctx, orderID},
	}
	mmDeleteReturnedOrder.expectations = append(mmDeleteReturnedOrder.expectations, expectation)
	return expectation
}

// Then sets up UseCase.DeleteReturnedOrder return parameters for the expectation previously defined by the When method
func (e *UseCaseMockDeleteReturnedOrderExpectation) Then(err error) *UseCaseMock {
	e.results = &UseCaseMockDeleteReturnedOrderResults{err}
	return e.mock
}

// DeleteReturnedOrder implements order.UseCase
func (mmDeleteReturnedOrder *UseCaseMock) DeleteReturnedOrder(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteReturnedOrder.beforeDeleteReturnedOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteReturnedOrder.afterDeleteReturnedOrderCounter, 1)

	if mmDeleteReturnedOrder.inspectFuncDeleteReturnedOrder != nil {
		mmDeleteReturnedOrder.inspectFuncDeleteReturnedOrder(ctx, orderID)
	}

	mm_params := UseCaseMockDeleteReturnedOrderParams{ctx, orderID}

	// Record call args
	mmDeleteReturnedOrder.DeleteReturnedOrderMock.mutex.Lock()
	mmDeleteReturnedOrder.DeleteReturnedOrderMock.callArgs = append(mmDeleteReturnedOrder.DeleteReturnedOrderMock.callArgs, &mm_params)
	mmDeleteReturnedOrder.DeleteReturnedOrderMock.mutex.Unlock()

	for _, e := range mmDeleteReturnedOrder.DeleteReturnedOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteReturnedOrder.DeleteReturnedOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteReturnedOrder.DeleteReturnedOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteReturnedOrder.DeleteReturnedOrderMock.defaultExpectation.params
		mm_got := UseCaseMockDeleteReturnedOrderParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteReturnedOrder.t.Errorf("UseCaseMock.DeleteReturnedOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteReturnedOrder.DeleteReturnedOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteReturnedOrder.t.Fatal("No results are set for the UseCaseMock.DeleteReturnedOrder")
		}
		return (*mm_results).err
	}
	if mmDeleteReturnedOrder.funcDeleteReturnedOrder != nil {
		return mmDeleteReturnedOrder.funcDeleteReturnedOrder(ctx, orderID)
	}
	mmDeleteReturnedOrder.t.Fatalf("Unexpected call to UseCaseMock.DeleteReturnedOrder. %v %v", ctx, orderID)
	return
}

// DeleteReturnedOrderAfterCounter returns a count of finished UseCaseMock.DeleteReturnedOrder invocations
func (mmDeleteReturnedOrder *UseCaseMock) DeleteReturnedOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteReturnedOrder.afterDeleteReturnedOrderCounter)
}

// DeleteReturnedOrderBeforeCounter returns a count of UseCaseMock.DeleteReturnedOrder invocations
func (mmDeleteReturnedOrder *UseCaseMock) DeleteReturnedOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteReturnedOrder.beforeDeleteReturnedOrderCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.DeleteReturnedOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteReturnedOrder *mUseCaseMockDeleteReturnedOrder) Calls() []*UseCaseMockDeleteReturnedOrderParams {
	mmDeleteReturnedOrder.mutex.RLock()

	argCopy := make([]*UseCaseMockDeleteReturnedOrderParams, len(mmDeleteReturnedOrder.callArgs))
	copy(argCopy, mmDeleteReturnedOrder.callArgs)

	mmDeleteReturnedOrder.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteReturnedOrderDone returns true if the count of the DeleteReturnedOrder invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockDeleteReturnedOrderDone() bool {
	for _, e := range m.DeleteReturnedOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteReturnedOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteReturnedOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteReturnedOrder != nil && mm_atomic.LoadUint64(&m.afterDeleteReturnedOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteReturnedOrderInspect logs each unmet expectation
func (m *UseCaseMock) MinimockDeleteReturnedOrderInspect() {
	for _, e := range m.DeleteReturnedOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.DeleteReturnedOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteReturnedOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteReturnedOrderCounter) < 1 {
		if m.DeleteReturnedOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.DeleteReturnedOrder")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.DeleteReturnedOrder with params: %#v", *m.DeleteReturnedOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteReturnedOrder != nil && mm_atomic.LoadUint64(&m.afterDeleteReturnedOrderCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.DeleteReturnedOrder")
	}
}

type mUseCaseMockIssueOrders struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockIssueOrdersExpectation
	expectations       []*UseCaseMockIssueOrdersExpectation

	callArgs []*UseCaseMockIssueOrdersParams
	mutex    sync.RWMutex
}

// UseCaseMockIssueOrdersExpectation specifies expectation struct of the UseCase.IssueOrders
type UseCaseMockIssueOrdersExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockIssueOrdersParams
	results *UseCaseMockIssueOrdersResults
	Counter uint64
}

// UseCaseMockIssueOrdersParams contains parameters of the UseCase.IssueOrders
type UseCaseMockIssueOrdersParams struct {
	ctx     context.Context
	request orderModel.RequestOrderIDs
}

// UseCaseMockIssueOrdersResults contains results of the UseCase.IssueOrders
type UseCaseMockIssueOrdersResults struct {
	f1  float64
	err error
}

// Expect sets up expected params for UseCase.IssueOrders
func (mmIssueOrders *mUseCaseMockIssueOrders) Expect(ctx context.Context, request orderModel.RequestOrderIDs) *mUseCaseMockIssueOrders {
	if mmIssueOrders.mock.funcIssueOrders != nil {
		mmIssueOrders.mock.t.Fatalf("UseCaseMock.IssueOrders mock is already set by Set")
	}

	if mmIssueOrders.defaultExpectation == nil {
		mmIssueOrders.defaultExpectation = &UseCaseMockIssueOrdersExpectation{}
	}

	mmIssueOrders.defaultExpectation.params = &UseCaseMockIssueOrdersParams{ctx, request}
	for _, e := range mmIssueOrders.expectations {
		if minimock.Equal(e.params, mmIssueOrders.defaultExpectation.params) {
			mmIssueOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIssueOrders.defaultExpectation.params)
		}
	}

	return mmIssueOrders
}

// Inspect accepts an inspector function that has same arguments as the UseCase.IssueOrders
func (mmIssueOrders *mUseCaseMockIssueOrders) Inspect(f func(ctx context.Context, request orderModel.RequestOrderIDs)) *mUseCaseMockIssueOrders {
	if mmIssueOrders.mock.inspectFuncIssueOrders != nil {
		mmIssueOrders.mock.t.Fatalf("Inspect function is already set for UseCaseMock.IssueOrders")
	}

	mmIssueOrders.mock.inspectFuncIssueOrders = f

	return mmIssueOrders
}

// Return sets up results that will be returned by UseCase.IssueOrders
func (mmIssueOrders *mUseCaseMockIssueOrders) Return(f1 float64, err error) *UseCaseMock {
	if mmIssueOrders.mock.funcIssueOrders != nil {
		mmIssueOrders.mock.t.Fatalf("UseCaseMock.IssueOrders mock is already set by Set")
	}

	if mmIssueOrders.defaultExpectation == nil {
		mmIssueOrders.defaultExpectation = &UseCaseMockIssueOrdersExpectation{mock: mmIssueOrders.mock}
	}
	mmIssueOrders.defaultExpectation.results = &UseCaseMockIssueOrdersResults{f1, err}
	return mmIssueOrders.mock
}

// Set uses given function f to mock the UseCase.IssueOrders method
func (mmIssueOrders *mUseCaseMockIssueOrders) Set(f func(ctx context.Context, request orderModel.RequestOrderIDs) (f1 float64, err error)) *UseCaseMock {
	if mmIssueOrders.defaultExpectation != nil {
		mmIssueOrders.mock.t.Fatalf("Default expectation is already set for the UseCase.IssueOrders method")
	}

	if len(mmIssueOrders.expectations) > 0 {
		mmIssueOrders.mock.t.Fatalf("Some expectations are already set for the UseCase.IssueOrders method")
	}

	mmIssueOrders.mock.funcIssueOrders = f
	return mmIssueOrders.mock
}

// When sets expectation for the UseCase.IssueOrders which will trigger the result defined by the following
// Then helper
func (mmIssueOrders *mUseCaseMockIssueOrders) When(ctx context.Context, request orderModel.RequestOrderIDs) *UseCaseMockIssueOrdersExpectation {
	if mmIssueOrders.mock.funcIssueOrders != nil {
		mmIssueOrders.mock.t.Fatalf("UseCaseMock.IssueOrders mock is already set by Set")
	}

	expectation := &UseCaseMockIssueOrdersExpectation{
		mock:   mmIssueOrders.mock,
		params: &UseCaseMockIssueOrdersParams{ctx, request},
	}
	mmIssueOrders.expectations = append(mmIssueOrders.expectations, expectation)
	return expectation
}

// Then sets up UseCase.IssueOrders return parameters for the expectation previously defined by the When method
func (e *UseCaseMockIssueOrdersExpectation) Then(f1 float64, err error) *UseCaseMock {
	e.results = &UseCaseMockIssueOrdersResults{f1, err}
	return e.mock
}

// IssueOrders implements order.UseCase
func (mmIssueOrders *UseCaseMock) IssueOrders(ctx context.Context, request orderModel.RequestOrderIDs) (f1 float64, err error) {
	mm_atomic.AddUint64(&mmIssueOrders.beforeIssueOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmIssueOrders.afterIssueOrdersCounter, 1)

	if mmIssueOrders.inspectFuncIssueOrders != nil {
		mmIssueOrders.inspectFuncIssueOrders(ctx, request)
	}

	mm_params := UseCaseMockIssueOrdersParams{ctx, request}

	// Record call args
	mmIssueOrders.IssueOrdersMock.mutex.Lock()
	mmIssueOrders.IssueOrdersMock.callArgs = append(mmIssueOrders.IssueOrdersMock.callArgs, &mm_params)
	mmIssueOrders.IssueOrdersMock.mutex.Unlock()

	for _, e := range mmIssueOrders.IssueOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmIssueOrders.IssueOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIssueOrders.IssueOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmIssueOrders.IssueOrdersMock.defaultExpectation.params
		mm_got := UseCaseMockIssueOrdersParams{ctx, request}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIssueOrders.t.Errorf("UseCaseMock.IssueOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIssueOrders.IssueOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmIssueOrders.t.Fatal("No results are set for the UseCaseMock.IssueOrders")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmIssueOrders.funcIssueOrders != nil {
		return mmIssueOrders.funcIssueOrders(ctx, request)
	}
	mmIssueOrders.t.Fatalf("Unexpected call to UseCaseMock.IssueOrders. %v %v", ctx, request)
	return
}

// IssueOrdersAfterCounter returns a count of finished UseCaseMock.IssueOrders invocations
func (mmIssueOrders *UseCaseMock) IssueOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIssueOrders.afterIssueOrdersCounter)
}

// IssueOrdersBeforeCounter returns a count of UseCaseMock.IssueOrders invocations
func (mmIssueOrders *UseCaseMock) IssueOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIssueOrders.beforeIssueOrdersCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.IssueOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIssueOrders *mUseCaseMockIssueOrders) Calls() []*UseCaseMockIssueOrdersParams {
	mmIssueOrders.mutex.RLock()

	argCopy := make([]*UseCaseMockIssueOrdersParams, len(mmIssueOrders.callArgs))
	copy(argCopy, mmIssueOrders.callArgs)

	mmIssueOrders.mutex.RUnlock()

	return argCopy
}

// MinimockIssueOrdersDone returns true if the count of the IssueOrders invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockIssueOrdersDone() bool {
	for _, e := range m.IssueOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IssueOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIssueOrdersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIssueOrders != nil && mm_atomic.LoadUint64(&m.afterIssueOrdersCounter) < 1 {
		return false
	}
	return true
}

// MinimockIssueOrdersInspect logs each unmet expectation
func (m *UseCaseMock) MinimockIssueOrdersInspect() {
	for _, e := range m.IssueOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.IssueOrders with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IssueOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIssueOrdersCounter) < 1 {
		if m.IssueOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.IssueOrders")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.IssueOrders with params: %#v", *m.IssueOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIssueOrders != nil && mm_atomic.LoadUint64(&m.afterIssueOrdersCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.IssueOrders")
	}
}

type mUseCaseMockOrderList struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockOrderListExpectation
	expectations       []*UseCaseMockOrderListExpectation

	callArgs []*UseCaseMockOrderListParams
	mutex    sync.RWMutex
}

// UseCaseMockOrderListExpectation specifies expectation struct of the UseCase.OrderList
type UseCaseMockOrderListExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockOrderListParams
	results *UseCaseMockOrderListResults
	Counter uint64
}

// UseCaseMockOrderListParams contains parameters of the UseCase.OrderList
type UseCaseMockOrderListParams struct {
	ctx     context.Context
	request abstract.Page
}

// UseCaseMockOrderListResults contains results of the UseCase.OrderList
type UseCaseMockOrderListResults struct {
	p1  abstract.PaginatedResponse[orderModel.AllResponse]
	err error
}

// Expect sets up expected params for UseCase.OrderList
func (mmOrderList *mUseCaseMockOrderList) Expect(ctx context.Context, request abstract.Page) *mUseCaseMockOrderList {
	if mmOrderList.mock.funcOrderList != nil {
		mmOrderList.mock.t.Fatalf("UseCaseMock.OrderList mock is already set by Set")
	}

	if mmOrderList.defaultExpectation == nil {
		mmOrderList.defaultExpectation = &UseCaseMockOrderListExpectation{}
	}

	mmOrderList.defaultExpectation.params = &UseCaseMockOrderListParams{ctx, request}
	for _, e := range mmOrderList.expectations {
		if minimock.Equal(e.params, mmOrderList.defaultExpectation.params) {
			mmOrderList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderList.defaultExpectation.params)
		}
	}

	return mmOrderList
}

// Inspect accepts an inspector function that has same arguments as the UseCase.OrderList
func (mmOrderList *mUseCaseMockOrderList) Inspect(f func(ctx context.Context, request abstract.Page)) *mUseCaseMockOrderList {
	if mmOrderList.mock.inspectFuncOrderList != nil {
		mmOrderList.mock.t.Fatalf("Inspect function is already set for UseCaseMock.OrderList")
	}

	mmOrderList.mock.inspectFuncOrderList = f

	return mmOrderList
}

// Return sets up results that will be returned by UseCase.OrderList
func (mmOrderList *mUseCaseMockOrderList) Return(p1 abstract.PaginatedResponse[orderModel.AllResponse], err error) *UseCaseMock {
	if mmOrderList.mock.funcOrderList != nil {
		mmOrderList.mock.t.Fatalf("UseCaseMock.OrderList mock is already set by Set")
	}

	if mmOrderList.defaultExpectation == nil {
		mmOrderList.defaultExpectation = &UseCaseMockOrderListExpectation{mock: mmOrderList.mock}
	}
	mmOrderList.defaultExpectation.results = &UseCaseMockOrderListResults{p1, err}
	return mmOrderList.mock
}

// Set uses given function f to mock the UseCase.OrderList method
func (mmOrderList *mUseCaseMockOrderList) Set(f func(ctx context.Context, request abstract.Page) (p1 abstract.PaginatedResponse[orderModel.AllResponse], err error)) *UseCaseMock {
	if mmOrderList.defaultExpectation != nil {
		mmOrderList.mock.t.Fatalf("Default expectation is already set for the UseCase.OrderList method")
	}

	if len(mmOrderList.expectations) > 0 {
		mmOrderList.mock.t.Fatalf("Some expectations are already set for the UseCase.OrderList method")
	}

	mmOrderList.mock.funcOrderList = f
	return mmOrderList.mock
}

// When sets expectation for the UseCase.OrderList which will trigger the result defined by the following
// Then helper
func (mmOrderList *mUseCaseMockOrderList) When(ctx context.Context, request abstract.Page) *UseCaseMockOrderListExpectation {
	if mmOrderList.mock.funcOrderList != nil {
		mmOrderList.mock.t.Fatalf("UseCaseMock.OrderList mock is already set by Set")
	}

	expectation := &UseCaseMockOrderListExpectation{
		mock:   mmOrderList.mock,
		params: &UseCaseMockOrderListParams{ctx, request},
	}
	mmOrderList.expectations = append(mmOrderList.expectations, expectation)
	return expectation
}

// Then sets up UseCase.OrderList return parameters for the expectation previously defined by the When method
func (e *UseCaseMockOrderListExpectation) Then(p1 abstract.PaginatedResponse[orderModel.AllResponse], err error) *UseCaseMock {
	e.results = &UseCaseMockOrderListResults{p1, err}
	return e.mock
}

// OrderList implements order.UseCase
func (mmOrderList *UseCaseMock) OrderList(ctx context.Context, request abstract.Page) (p1 abstract.PaginatedResponse[orderModel.AllResponse], err error) {
	mm_atomic.AddUint64(&mmOrderList.beforeOrderListCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderList.afterOrderListCounter, 1)

	if mmOrderList.inspectFuncOrderList != nil {
		mmOrderList.inspectFuncOrderList(ctx, request)
	}

	mm_params := UseCaseMockOrderListParams{ctx, request}

	// Record call args
	mmOrderList.OrderListMock.mutex.Lock()
	mmOrderList.OrderListMock.callArgs = append(mmOrderList.OrderListMock.callArgs, &mm_params)
	mmOrderList.OrderListMock.mutex.Unlock()

	for _, e := range mmOrderList.OrderListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmOrderList.OrderListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderList.OrderListMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderList.OrderListMock.defaultExpectation.params
		mm_got := UseCaseMockOrderListParams{ctx, request}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderList.t.Errorf("UseCaseMock.OrderList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderList.OrderListMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderList.t.Fatal("No results are set for the UseCaseMock.OrderList")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmOrderList.funcOrderList != nil {
		return mmOrderList.funcOrderList(ctx, request)
	}
	mmOrderList.t.Fatalf("Unexpected call to UseCaseMock.OrderList. %v %v", ctx, request)
	return
}

// OrderListAfterCounter returns a count of finished UseCaseMock.OrderList invocations
func (mmOrderList *UseCaseMock) OrderListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderList.afterOrderListCounter)
}

// OrderListBeforeCounter returns a count of UseCaseMock.OrderList invocations
func (mmOrderList *UseCaseMock) OrderListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderList.beforeOrderListCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.OrderList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderList *mUseCaseMockOrderList) Calls() []*UseCaseMockOrderListParams {
	mmOrderList.mutex.RLock()

	argCopy := make([]*UseCaseMockOrderListParams, len(mmOrderList.callArgs))
	copy(argCopy, mmOrderList.callArgs)

	mmOrderList.mutex.RUnlock()

	return argCopy
}

// MinimockOrderListDone returns true if the count of the OrderList invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockOrderListDone() bool {
	for _, e := range m.OrderListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderList != nil && mm_atomic.LoadUint64(&m.afterOrderListCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderListInspect logs each unmet expectation
func (m *UseCaseMock) MinimockOrderListInspect() {
	for _, e := range m.OrderListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.OrderList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderListCounter) < 1 {
		if m.OrderListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.OrderList")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.OrderList with params: %#v", *m.OrderListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderList != nil && mm_atomic.LoadUint64(&m.afterOrderListCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.OrderList")
	}
}

type mUseCaseMockReturnedOrders struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockReturnedOrdersExpectation
	expectations       []*UseCaseMockReturnedOrdersExpectation

	callArgs []*UseCaseMockReturnedOrdersParams
	mutex    sync.RWMutex
}

// UseCaseMockReturnedOrdersExpectation specifies expectation struct of the UseCase.ReturnedOrders
type UseCaseMockReturnedOrdersExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockReturnedOrdersParams
	results *UseCaseMockReturnedOrdersResults
	Counter uint64
}

// UseCaseMockReturnedOrdersParams contains parameters of the UseCase.ReturnedOrders
type UseCaseMockReturnedOrdersParams struct {
	ctx     context.Context
	request abstract.Page
}

// UseCaseMockReturnedOrdersResults contains results of the UseCase.ReturnedOrders
type UseCaseMockReturnedOrdersResults struct {
	p1  abstract.PaginatedResponse[orderModel.ReturnedResponse]
	err error
}

// Expect sets up expected params for UseCase.ReturnedOrders
func (mmReturnedOrders *mUseCaseMockReturnedOrders) Expect(ctx context.Context, request abstract.Page) *mUseCaseMockReturnedOrders {
	if mmReturnedOrders.mock.funcReturnedOrders != nil {
		mmReturnedOrders.mock.t.Fatalf("UseCaseMock.ReturnedOrders mock is already set by Set")
	}

	if mmReturnedOrders.defaultExpectation == nil {
		mmReturnedOrders.defaultExpectation = &UseCaseMockReturnedOrdersExpectation{}
	}

	mmReturnedOrders.defaultExpectation.params = &UseCaseMockReturnedOrdersParams{ctx, request}
	for _, e := range mmReturnedOrders.expectations {
		if minimock.Equal(e.params, mmReturnedOrders.defaultExpectation.params) {
			mmReturnedOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReturnedOrders.defaultExpectation.params)
		}
	}

	return mmReturnedOrders
}

// Inspect accepts an inspector function that has same arguments as the UseCase.ReturnedOrders
func (mmReturnedOrders *mUseCaseMockReturnedOrders) Inspect(f func(ctx context.Context, request abstract.Page)) *mUseCaseMockReturnedOrders {
	if mmReturnedOrders.mock.inspectFuncReturnedOrders != nil {
		mmReturnedOrders.mock.t.Fatalf("Inspect function is already set for UseCaseMock.ReturnedOrders")
	}

	mmReturnedOrders.mock.inspectFuncReturnedOrders = f

	return mmReturnedOrders
}

// Return sets up results that will be returned by UseCase.ReturnedOrders
func (mmReturnedOrders *mUseCaseMockReturnedOrders) Return(p1 abstract.PaginatedResponse[orderModel.ReturnedResponse], err error) *UseCaseMock {
	if mmReturnedOrders.mock.funcReturnedOrders != nil {
		mmReturnedOrders.mock.t.Fatalf("UseCaseMock.ReturnedOrders mock is already set by Set")
	}

	if mmReturnedOrders.defaultExpectation == nil {
		mmReturnedOrders.defaultExpectation = &UseCaseMockReturnedOrdersExpectation{mock: mmReturnedOrders.mock}
	}
	mmReturnedOrders.defaultExpectation.results = &UseCaseMockReturnedOrdersResults{p1, err}
	return mmReturnedOrders.mock
}

// Set uses given function f to mock the UseCase.ReturnedOrders method
func (mmReturnedOrders *mUseCaseMockReturnedOrders) Set(f func(ctx context.Context, request abstract.Page) (p1 abstract.PaginatedResponse[orderModel.ReturnedResponse], err error)) *UseCaseMock {
	if mmReturnedOrders.defaultExpectation != nil {
		mmReturnedOrders.mock.t.Fatalf("Default expectation is already set for the UseCase.ReturnedOrders method")
	}

	if len(mmReturnedOrders.expectations) > 0 {
		mmReturnedOrders.mock.t.Fatalf("Some expectations are already set for the UseCase.ReturnedOrders method")
	}

	mmReturnedOrders.mock.funcReturnedOrders = f
	return mmReturnedOrders.mock
}

// When sets expectation for the UseCase.ReturnedOrders which will trigger the result defined by the following
// Then helper
func (mmReturnedOrders *mUseCaseMockReturnedOrders) When(ctx context.Context, request abstract.Page) *UseCaseMockReturnedOrdersExpectation {
	if mmReturnedOrders.mock.funcReturnedOrders != nil {
		mmReturnedOrders.mock.t.Fatalf("UseCaseMock.ReturnedOrders mock is already set by Set")
	}

	expectation := &UseCaseMockReturnedOrdersExpectation{
		mock:   mmReturnedOrders.mock,
		params: &UseCaseMockReturnedOrdersParams{ctx, request},
	}
	mmReturnedOrders.expectations = append(mmReturnedOrders.expectations, expectation)
	return expectation
}

// Then sets up UseCase.ReturnedOrders return parameters for the expectation previously defined by the When method
func (e *UseCaseMockReturnedOrdersExpectation) Then(p1 abstract.PaginatedResponse[orderModel.ReturnedResponse], err error) *UseCaseMock {
	e.results = &UseCaseMockReturnedOrdersResults{p1, err}
	return e.mock
}

// ReturnedOrders implements order.UseCase
func (mmReturnedOrders *UseCaseMock) ReturnedOrders(ctx context.Context, request abstract.Page) (p1 abstract.PaginatedResponse[orderModel.ReturnedResponse], err error) {
	mm_atomic.AddUint64(&mmReturnedOrders.beforeReturnedOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmReturnedOrders.afterReturnedOrdersCounter, 1)

	if mmReturnedOrders.inspectFuncReturnedOrders != nil {
		mmReturnedOrders.inspectFuncReturnedOrders(ctx, request)
	}

	mm_params := UseCaseMockReturnedOrdersParams{ctx, request}

	// Record call args
	mmReturnedOrders.ReturnedOrdersMock.mutex.Lock()
	mmReturnedOrders.ReturnedOrdersMock.callArgs = append(mmReturnedOrders.ReturnedOrdersMock.callArgs, &mm_params)
	mmReturnedOrders.ReturnedOrdersMock.mutex.Unlock()

	for _, e := range mmReturnedOrders.ReturnedOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmReturnedOrders.ReturnedOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReturnedOrders.ReturnedOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmReturnedOrders.ReturnedOrdersMock.defaultExpectation.params
		mm_got := UseCaseMockReturnedOrdersParams{ctx, request}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReturnedOrders.t.Errorf("UseCaseMock.ReturnedOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReturnedOrders.ReturnedOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmReturnedOrders.t.Fatal("No results are set for the UseCaseMock.ReturnedOrders")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmReturnedOrders.funcReturnedOrders != nil {
		return mmReturnedOrders.funcReturnedOrders(ctx, request)
	}
	mmReturnedOrders.t.Fatalf("Unexpected call to UseCaseMock.ReturnedOrders. %v %v", ctx, request)
	return
}

// ReturnedOrdersAfterCounter returns a count of finished UseCaseMock.ReturnedOrders invocations
func (mmReturnedOrders *UseCaseMock) ReturnedOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnedOrders.afterReturnedOrdersCounter)
}

// ReturnedOrdersBeforeCounter returns a count of UseCaseMock.ReturnedOrders invocations
func (mmReturnedOrders *UseCaseMock) ReturnedOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnedOrders.beforeReturnedOrdersCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.ReturnedOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReturnedOrders *mUseCaseMockReturnedOrders) Calls() []*UseCaseMockReturnedOrdersParams {
	mmReturnedOrders.mutex.RLock()

	argCopy := make([]*UseCaseMockReturnedOrdersParams, len(mmReturnedOrders.callArgs))
	copy(argCopy, mmReturnedOrders.callArgs)

	mmReturnedOrders.mutex.RUnlock()

	return argCopy
}

// MinimockReturnedOrdersDone returns true if the count of the ReturnedOrders invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockReturnedOrdersDone() bool {
	for _, e := range m.ReturnedOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReturnedOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReturnedOrdersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReturnedOrders != nil && mm_atomic.LoadUint64(&m.afterReturnedOrdersCounter) < 1 {
		return false
	}
	return true
}

// MinimockReturnedOrdersInspect logs each unmet expectation
func (m *UseCaseMock) MinimockReturnedOrdersInspect() {
	for _, e := range m.ReturnedOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.ReturnedOrders with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReturnedOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReturnedOrdersCounter) < 1 {
		if m.ReturnedOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.ReturnedOrders")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.ReturnedOrders with params: %#v", *m.ReturnedOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReturnedOrders != nil && mm_atomic.LoadUint64(&m.afterReturnedOrdersCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.ReturnedOrders")
	}
}

type mUseCaseMockUniqueClientsList struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockUniqueClientsListExpectation
	expectations       []*UseCaseMockUniqueClientsListExpectation

	callArgs []*UseCaseMockUniqueClientsListParams
	mutex    sync.RWMutex
}

// UseCaseMockUniqueClientsListExpectation specifies expectation struct of the UseCase.UniqueClientsList
type UseCaseMockUniqueClientsListExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockUniqueClientsListParams
	results *UseCaseMockUniqueClientsListResults
	Counter uint64
}

// UseCaseMockUniqueClientsListParams contains parameters of the UseCase.UniqueClientsList
type UseCaseMockUniqueClientsListParams struct {
	ctx     context.Context
	request abstract.Page
}

// UseCaseMockUniqueClientsListResults contains results of the UseCase.UniqueClientsList
type UseCaseMockUniqueClientsListResults struct {
	p1  abstract.PaginatedResponse[orderModel.ListUniqueClients]
	err error
}

// Expect sets up expected params for UseCase.UniqueClientsList
func (mmUniqueClientsList *mUseCaseMockUniqueClientsList) Expect(ctx context.Context, request abstract.Page) *mUseCaseMockUniqueClientsList {
	if mmUniqueClientsList.mock.funcUniqueClientsList != nil {
		mmUniqueClientsList.mock.t.Fatalf("UseCaseMock.UniqueClientsList mock is already set by Set")
	}

	if mmUniqueClientsList.defaultExpectation == nil {
		mmUniqueClientsList.defaultExpectation = &UseCaseMockUniqueClientsListExpectation{}
	}

	mmUniqueClientsList.defaultExpectation.params = &UseCaseMockUniqueClientsListParams{ctx, request}
	for _, e := range mmUniqueClientsList.expectations {
		if minimock.Equal(e.params, mmUniqueClientsList.defaultExpectation.params) {
			mmUniqueClientsList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUniqueClientsList.defaultExpectation.params)
		}
	}

	return mmUniqueClientsList
}

// Inspect accepts an inspector function that has same arguments as the UseCase.UniqueClientsList
func (mmUniqueClientsList *mUseCaseMockUniqueClientsList) Inspect(f func(ctx context.Context, request abstract.Page)) *mUseCaseMockUniqueClientsList {
	if mmUniqueClientsList.mock.inspectFuncUniqueClientsList != nil {
		mmUniqueClientsList.mock.t.Fatalf("Inspect function is already set for UseCaseMock.UniqueClientsList")
	}

	mmUniqueClientsList.mock.inspectFuncUniqueClientsList = f

	return mmUniqueClientsList
}

// Return sets up results that will be returned by UseCase.UniqueClientsList
func (mmUniqueClientsList *mUseCaseMockUniqueClientsList) Return(p1 abstract.PaginatedResponse[orderModel.ListUniqueClients], err error) *UseCaseMock {
	if mmUniqueClientsList.mock.funcUniqueClientsList != nil {
		mmUniqueClientsList.mock.t.Fatalf("UseCaseMock.UniqueClientsList mock is already set by Set")
	}

	if mmUniqueClientsList.defaultExpectation == nil {
		mmUniqueClientsList.defaultExpectation = &UseCaseMockUniqueClientsListExpectation{mock: mmUniqueClientsList.mock}
	}
	mmUniqueClientsList.defaultExpectation.results = &UseCaseMockUniqueClientsListResults{p1, err}
	return mmUniqueClientsList.mock
}

// Set uses given function f to mock the UseCase.UniqueClientsList method
func (mmUniqueClientsList *mUseCaseMockUniqueClientsList) Set(f func(ctx context.Context, request abstract.Page) (p1 abstract.PaginatedResponse[orderModel.ListUniqueClients], err error)) *UseCaseMock {
	if mmUniqueClientsList.defaultExpectation != nil {
		mmUniqueClientsList.mock.t.Fatalf("Default expectation is already set for the UseCase.UniqueClientsList method")
	}

	if len(mmUniqueClientsList.expectations) > 0 {
		mmUniqueClientsList.mock.t.Fatalf("Some expectations are already set for the UseCase.UniqueClientsList method")
	}

	mmUniqueClientsList.mock.funcUniqueClientsList = f
	return mmUniqueClientsList.mock
}

// When sets expectation for the UseCase.UniqueClientsList which will trigger the result defined by the following
// Then helper
func (mmUniqueClientsList *mUseCaseMockUniqueClientsList) When(ctx context.Context, request abstract.Page) *UseCaseMockUniqueClientsListExpectation {
	if mmUniqueClientsList.mock.funcUniqueClientsList != nil {
		mmUniqueClientsList.mock.t.Fatalf("UseCaseMock.UniqueClientsList mock is already set by Set")
	}

	expectation := &UseCaseMockUniqueClientsListExpectation{
		mock:   mmUniqueClientsList.mock,
		params: &UseCaseMockUniqueClientsListParams{ctx, request},
	}
	mmUniqueClientsList.expectations = append(mmUniqueClientsList.expectations, expectation)
	return expectation
}

// Then sets up UseCase.UniqueClientsList return parameters for the expectation previously defined by the When method
func (e *UseCaseMockUniqueClientsListExpectation) Then(p1 abstract.PaginatedResponse[orderModel.ListUniqueClients], err error) *UseCaseMock {
	e.results = &UseCaseMockUniqueClientsListResults{p1, err}
	return e.mock
}

// UniqueClientsList implements order.UseCase
func (mmUniqueClientsList *UseCaseMock) UniqueClientsList(ctx context.Context, request abstract.Page) (p1 abstract.PaginatedResponse[orderModel.ListUniqueClients], err error) {
	mm_atomic.AddUint64(&mmUniqueClientsList.beforeUniqueClientsListCounter, 1)
	defer mm_atomic.AddUint64(&mmUniqueClientsList.afterUniqueClientsListCounter, 1)

	if mmUniqueClientsList.inspectFuncUniqueClientsList != nil {
		mmUniqueClientsList.inspectFuncUniqueClientsList(ctx, request)
	}

	mm_params := UseCaseMockUniqueClientsListParams{ctx, request}

	// Record call args
	mmUniqueClientsList.UniqueClientsListMock.mutex.Lock()
	mmUniqueClientsList.UniqueClientsListMock.callArgs = append(mmUniqueClientsList.UniqueClientsListMock.callArgs, &mm_params)
	mmUniqueClientsList.UniqueClientsListMock.mutex.Unlock()

	for _, e := range mmUniqueClientsList.UniqueClientsListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmUniqueClientsList.UniqueClientsListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUniqueClientsList.UniqueClientsListMock.defaultExpectation.Counter, 1)
		mm_want := mmUniqueClientsList.UniqueClientsListMock.defaultExpectation.params
		mm_got := UseCaseMockUniqueClientsListParams{ctx, request}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUniqueClientsList.t.Errorf("UseCaseMock.UniqueClientsList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUniqueClientsList.UniqueClientsListMock.defaultExpectation.results
		if mm_results == nil {
			mmUniqueClientsList.t.Fatal("No results are set for the UseCaseMock.UniqueClientsList")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmUniqueClientsList.funcUniqueClientsList != nil {
		return mmUniqueClientsList.funcUniqueClientsList(ctx, request)
	}
	mmUniqueClientsList.t.Fatalf("Unexpected call to UseCaseMock.UniqueClientsList. %v %v", ctx, request)
	return
}

// UniqueClientsListAfterCounter returns a count of finished UseCaseMock.UniqueClientsList invocations
func (mmUniqueClientsList *UseCaseMock) UniqueClientsListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUniqueClientsList.afterUniqueClientsListCounter)
}

// UniqueClientsListBeforeCounter returns a count of UseCaseMock.UniqueClientsList invocations
func (mmUniqueClientsList *UseCaseMock) UniqueClientsListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUniqueClientsList.beforeUniqueClientsListCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.UniqueClientsList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUniqueClientsList *mUseCaseMockUniqueClientsList) Calls() []*UseCaseMockUniqueClientsListParams {
	mmUniqueClientsList.mutex.RLock()

	argCopy := make([]*UseCaseMockUniqueClientsListParams, len(mmUniqueClientsList.callArgs))
	copy(argCopy, mmUniqueClientsList.callArgs)

	mmUniqueClientsList.mutex.RUnlock()

	return argCopy
}

// MinimockUniqueClientsListDone returns true if the count of the UniqueClientsList invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockUniqueClientsListDone() bool {
	for _, e := range m.UniqueClientsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UniqueClientsListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUniqueClientsListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUniqueClientsList != nil && mm_atomic.LoadUint64(&m.afterUniqueClientsListCounter) < 1 {
		return false
	}
	return true
}

// MinimockUniqueClientsListInspect logs each unmet expectation
func (m *UseCaseMock) MinimockUniqueClientsListInspect() {
	for _, e := range m.UniqueClientsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.UniqueClientsList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UniqueClientsListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUniqueClientsListCounter) < 1 {
		if m.UniqueClientsListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.UniqueClientsList")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.UniqueClientsList with params: %#v", *m.UniqueClientsListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUniqueClientsList != nil && mm_atomic.LoadUint64(&m.afterUniqueClientsListCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.UniqueClientsList")
	}
}

type mUseCaseMockUpdateAcceptOrder struct {
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockUpdateAcceptOrderExpectation
	expectations       []*UseCaseMockUpdateAcceptOrderExpectation

	callArgs []*UseCaseMockUpdateAcceptOrderParams
	mutex    sync.RWMutex
}

// UseCaseMockUpdateAcceptOrderExpectation specifies expectation struct of the UseCase.UpdateAcceptOrder
type UseCaseMockUpdateAcceptOrderExpectation struct {
	mock    *UseCaseMock
	params  *UseCaseMockUpdateAcceptOrderParams
	results *UseCaseMockUpdateAcceptOrderResults
	Counter uint64
}

// UseCaseMockUpdateAcceptOrderParams contains parameters of the UseCase.UpdateAcceptOrder
type UseCaseMockUpdateAcceptOrderParams struct {
	ctx     context.Context
	request orderModel.RequestWithClientID
}

// UseCaseMockUpdateAcceptOrderResults contains results of the UseCase.UpdateAcceptOrder
type UseCaseMockUpdateAcceptOrderResults struct {
	err error
}

// Expect sets up expected params for UseCase.UpdateAcceptOrder
func (mmUpdateAcceptOrder *mUseCaseMockUpdateAcceptOrder) Expect(ctx context.Context, request orderModel.RequestWithClientID) *mUseCaseMockUpdateAcceptOrder {
	if mmUpdateAcceptOrder.mock.funcUpdateAcceptOrder != nil {
		mmUpdateAcceptOrder.mock.t.Fatalf("UseCaseMock.UpdateAcceptOrder mock is already set by Set")
	}

	if mmUpdateAcceptOrder.defaultExpectation == nil {
		mmUpdateAcceptOrder.defaultExpectation = &UseCaseMockUpdateAcceptOrderExpectation{}
	}

	mmUpdateAcceptOrder.defaultExpectation.params = &UseCaseMockUpdateAcceptOrderParams{ctx, request}
	for _, e := range mmUpdateAcceptOrder.expectations {
		if minimock.Equal(e.params, mmUpdateAcceptOrder.defaultExpectation.params) {
			mmUpdateAcceptOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateAcceptOrder.defaultExpectation.params)
		}
	}

	return mmUpdateAcceptOrder
}

// Inspect accepts an inspector function that has same arguments as the UseCase.UpdateAcceptOrder
func (mmUpdateAcceptOrder *mUseCaseMockUpdateAcceptOrder) Inspect(f func(ctx context.Context, request orderModel.RequestWithClientID)) *mUseCaseMockUpdateAcceptOrder {
	if mmUpdateAcceptOrder.mock.inspectFuncUpdateAcceptOrder != nil {
		mmUpdateAcceptOrder.mock.t.Fatalf("Inspect function is already set for UseCaseMock.UpdateAcceptOrder")
	}

	mmUpdateAcceptOrder.mock.inspectFuncUpdateAcceptOrder = f

	return mmUpdateAcceptOrder
}

// Return sets up results that will be returned by UseCase.UpdateAcceptOrder
func (mmUpdateAcceptOrder *mUseCaseMockUpdateAcceptOrder) Return(err error) *UseCaseMock {
	if mmUpdateAcceptOrder.mock.funcUpdateAcceptOrder != nil {
		mmUpdateAcceptOrder.mock.t.Fatalf("UseCaseMock.UpdateAcceptOrder mock is already set by Set")
	}

	if mmUpdateAcceptOrder.defaultExpectation == nil {
		mmUpdateAcceptOrder.defaultExpectation = &UseCaseMockUpdateAcceptOrderExpectation{mock: mmUpdateAcceptOrder.mock}
	}
	mmUpdateAcceptOrder.defaultExpectation.results = &UseCaseMockUpdateAcceptOrderResults{err}
	return mmUpdateAcceptOrder.mock
}

// Set uses given function f to mock the UseCase.UpdateAcceptOrder method
func (mmUpdateAcceptOrder *mUseCaseMockUpdateAcceptOrder) Set(f func(ctx context.Context, request orderModel.RequestWithClientID) (err error)) *UseCaseMock {
	if mmUpdateAcceptOrder.defaultExpectation != nil {
		mmUpdateAcceptOrder.mock.t.Fatalf("Default expectation is already set for the UseCase.UpdateAcceptOrder method")
	}

	if len(mmUpdateAcceptOrder.expectations) > 0 {
		mmUpdateAcceptOrder.mock.t.Fatalf("Some expectations are already set for the UseCase.UpdateAcceptOrder method")
	}

	mmUpdateAcceptOrder.mock.funcUpdateAcceptOrder = f
	return mmUpdateAcceptOrder.mock
}

// When sets expectation for the UseCase.UpdateAcceptOrder which will trigger the result defined by the following
// Then helper
func (mmUpdateAcceptOrder *mUseCaseMockUpdateAcceptOrder) When(ctx context.Context, request orderModel.RequestWithClientID) *UseCaseMockUpdateAcceptOrderExpectation {
	if mmUpdateAcceptOrder.mock.funcUpdateAcceptOrder != nil {
		mmUpdateAcceptOrder.mock.t.Fatalf("UseCaseMock.UpdateAcceptOrder mock is already set by Set")
	}

	expectation := &UseCaseMockUpdateAcceptOrderExpectation{
		mock:   mmUpdateAcceptOrder.mock,
		params: &UseCaseMockUpdateAcceptOrderParams{ctx, request},
	}
	mmUpdateAcceptOrder.expectations = append(mmUpdateAcceptOrder.expectations, expectation)
	return expectation
}

// Then sets up UseCase.UpdateAcceptOrder return parameters for the expectation previously defined by the When method
func (e *UseCaseMockUpdateAcceptOrderExpectation) Then(err error) *UseCaseMock {
	e.results = &UseCaseMockUpdateAcceptOrderResults{err}
	return e.mock
}

// UpdateAcceptOrder implements order.UseCase
func (mmUpdateAcceptOrder *UseCaseMock) UpdateAcceptOrder(ctx context.Context, request orderModel.RequestWithClientID) (err error) {
	mm_atomic.AddUint64(&mmUpdateAcceptOrder.beforeUpdateAcceptOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateAcceptOrder.afterUpdateAcceptOrderCounter, 1)

	if mmUpdateAcceptOrder.inspectFuncUpdateAcceptOrder != nil {
		mmUpdateAcceptOrder.inspectFuncUpdateAcceptOrder(ctx, request)
	}

	mm_params := UseCaseMockUpdateAcceptOrderParams{ctx, request}

	// Record call args
	mmUpdateAcceptOrder.UpdateAcceptOrderMock.mutex.Lock()
	mmUpdateAcceptOrder.UpdateAcceptOrderMock.callArgs = append(mmUpdateAcceptOrder.UpdateAcceptOrderMock.callArgs, &mm_params)
	mmUpdateAcceptOrder.UpdateAcceptOrderMock.mutex.Unlock()

	for _, e := range mmUpdateAcceptOrder.UpdateAcceptOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateAcceptOrder.UpdateAcceptOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateAcceptOrder.UpdateAcceptOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateAcceptOrder.UpdateAcceptOrderMock.defaultExpectation.params
		mm_got := UseCaseMockUpdateAcceptOrderParams{ctx, request}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateAcceptOrder.t.Errorf("UseCaseMock.UpdateAcceptOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateAcceptOrder.UpdateAcceptOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateAcceptOrder.t.Fatal("No results are set for the UseCaseMock.UpdateAcceptOrder")
		}
		return (*mm_results).err
	}
	if mmUpdateAcceptOrder.funcUpdateAcceptOrder != nil {
		return mmUpdateAcceptOrder.funcUpdateAcceptOrder(ctx, request)
	}
	mmUpdateAcceptOrder.t.Fatalf("Unexpected call to UseCaseMock.UpdateAcceptOrder. %v %v", ctx, request)
	return
}

// UpdateAcceptOrderAfterCounter returns a count of finished UseCaseMock.UpdateAcceptOrder invocations
func (mmUpdateAcceptOrder *UseCaseMock) UpdateAcceptOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAcceptOrder.afterUpdateAcceptOrderCounter)
}

// UpdateAcceptOrderBeforeCounter returns a count of UseCaseMock.UpdateAcceptOrder invocations
func (mmUpdateAcceptOrder *UseCaseMock) UpdateAcceptOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAcceptOrder.beforeUpdateAcceptOrderCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.UpdateAcceptOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateAcceptOrder *mUseCaseMockUpdateAcceptOrder) Calls() []*UseCaseMockUpdateAcceptOrderParams {
	mmUpdateAcceptOrder.mutex.RLock()

	argCopy := make([]*UseCaseMockUpdateAcceptOrderParams, len(mmUpdateAcceptOrder.callArgs))
	copy(argCopy, mmUpdateAcceptOrder.callArgs)

	mmUpdateAcceptOrder.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateAcceptOrderDone returns true if the count of the UpdateAcceptOrder invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockUpdateAcceptOrderDone() bool {
	for _, e := range m.UpdateAcceptOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAcceptOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateAcceptOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAcceptOrder != nil && mm_atomic.LoadUint64(&m.afterUpdateAcceptOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateAcceptOrderInspect logs each unmet expectation
func (m *UseCaseMock) MinimockUpdateAcceptOrderInspect() {
	for _, e := range m.UpdateAcceptOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.UpdateAcceptOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAcceptOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateAcceptOrderCounter) < 1 {
		if m.UpdateAcceptOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UseCaseMock.UpdateAcceptOrder")
		} else {
			m.t.Errorf("Expected call to UseCaseMock.UpdateAcceptOrder with params: %#v", *m.UpdateAcceptOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAcceptOrder != nil && mm_atomic.LoadUint64(&m.afterUpdateAcceptOrderCounter) < 1 {
		m.t.Error("Expected call to UseCaseMock.UpdateAcceptOrder")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UseCaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateReceiveOrderInspect()

			m.MinimockDeleteReturnedOrderInspect()

			m.MinimockIssueOrdersInspect()

			m.MinimockOrderListInspect()

			m.MinimockReturnedOrdersInspect()

			m.MinimockUniqueClientsListInspect()

			m.MinimockUpdateAcceptOrderInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UseCaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UseCaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateReceiveOrderDone() &&
		m.MinimockDeleteReturnedOrderDone() &&
		m.MinimockIssueOrdersDone() &&
		m.MinimockOrderListDone() &&
		m.MinimockReturnedOrdersDone() &&
		m.MinimockUniqueClientsListDone() &&
		m.MinimockUpdateAcceptOrderDone()
}
