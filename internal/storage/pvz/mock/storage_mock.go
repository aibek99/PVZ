// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mock

import (
	"Homework-1/internal/model/cli"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StorageMock implements pvz.Storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mStorageMockClose

	funcCreate          func(value *cli.PVZ) (err error)
	inspectFuncCreate   func(value *cli.PVZ)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mStorageMockCreate

	funcFind          func(key string) (p1 cli.PVZ, err error)
	inspectFuncFind   func(key string)
	afterFindCounter  uint64
	beforeFindCounter uint64
	FindMock          mStorageMockFind

	funcReadAll          func() (err error)
	inspectFuncReadAll   func()
	afterReadAllCounter  uint64
	beforeReadAllCounter uint64
	ReadAllMock          mStorageMockReadAll

	funcSave          func() (err error)
	inspectFuncSave   func()
	afterSaveCounter  uint64
	beforeSaveCounter uint64
	SaveMock          mStorageMockSave
}

// NewStorageMock returns a mock for pvz.Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mStorageMockClose{mock: m}

	m.CreateMock = mStorageMockCreate{mock: m}
	m.CreateMock.callArgs = []*StorageMockCreateParams{}

	m.FindMock = mStorageMockFind{mock: m}
	m.FindMock.callArgs = []*StorageMockFindParams{}

	m.ReadAllMock = mStorageMockReadAll{mock: m}

	m.SaveMock = mStorageMockSave{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockClose struct {
	mock               *StorageMock
	defaultExpectation *StorageMockCloseExpectation
	expectations       []*StorageMockCloseExpectation
}

// StorageMockCloseExpectation specifies expectation struct of the Storage.Close
type StorageMockCloseExpectation struct {
	mock *StorageMock

	results *StorageMockCloseResults
	Counter uint64
}

// StorageMockCloseResults contains results of the Storage.Close
type StorageMockCloseResults struct {
	err error
}

// Expect sets up expected params for Storage.Close
func (mmClose *mStorageMockClose) Expect() *mStorageMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("StorageMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &StorageMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Storage.Close
func (mmClose *mStorageMockClose) Inspect(f func()) *mStorageMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for StorageMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Storage.Close
func (mmClose *mStorageMockClose) Return(err error) *StorageMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("StorageMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &StorageMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &StorageMockCloseResults{err}
	return mmClose.mock
}

// Set uses given function f to mock the Storage.Close method
func (mmClose *mStorageMockClose) Set(f func() (err error)) *StorageMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Storage.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Storage.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements pvz.Storage
func (mmClose *StorageMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the StorageMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to StorageMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished StorageMock.Close invocations
func (mmClose *StorageMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of StorageMock.Close invocations
func (mmClose *StorageMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *StorageMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Close")
	}
}

type mStorageMockCreate struct {
	mock               *StorageMock
	defaultExpectation *StorageMockCreateExpectation
	expectations       []*StorageMockCreateExpectation

	callArgs []*StorageMockCreateParams
	mutex    sync.RWMutex
}

// StorageMockCreateExpectation specifies expectation struct of the Storage.Create
type StorageMockCreateExpectation struct {
	mock    *StorageMock
	params  *StorageMockCreateParams
	results *StorageMockCreateResults
	Counter uint64
}

// StorageMockCreateParams contains parameters of the Storage.Create
type StorageMockCreateParams struct {
	value *cli.PVZ
}

// StorageMockCreateResults contains results of the Storage.Create
type StorageMockCreateResults struct {
	err error
}

// Expect sets up expected params for Storage.Create
func (mmCreate *mStorageMockCreate) Expect(value *cli.PVZ) *mStorageMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("StorageMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &StorageMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &StorageMockCreateParams{value}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Storage.Create
func (mmCreate *mStorageMockCreate) Inspect(f func(value *cli.PVZ)) *mStorageMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for StorageMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Storage.Create
func (mmCreate *mStorageMockCreate) Return(err error) *StorageMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("StorageMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &StorageMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &StorageMockCreateResults{err}
	return mmCreate.mock
}

// Set uses given function f to mock the Storage.Create method
func (mmCreate *mStorageMockCreate) Set(f func(value *cli.PVZ) (err error)) *StorageMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Storage.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Storage.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the Storage.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mStorageMockCreate) When(value *cli.PVZ) *StorageMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("StorageMock.Create mock is already set by Set")
	}

	expectation := &StorageMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &StorageMockCreateParams{value},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Storage.Create return parameters for the expectation previously defined by the When method
func (e *StorageMockCreateExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockCreateResults{err}
	return e.mock
}

// Create implements pvz.Storage
func (mmCreate *StorageMock) Create(value *cli.PVZ) (err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(value)
	}

	mm_params := StorageMockCreateParams{value}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := StorageMockCreateParams{value}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("StorageMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the StorageMock.Create")
		}
		return (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(value)
	}
	mmCreate.t.Fatalf("Unexpected call to StorageMock.Create. %v", value)
	return
}

// CreateAfterCounter returns a count of finished StorageMock.Create invocations
func (mmCreate *StorageMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of StorageMock.Create invocations
func (mmCreate *StorageMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mStorageMockCreate) Calls() []*StorageMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*StorageMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *StorageMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.Create")
		} else {
			m.t.Errorf("Expected call to StorageMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Create")
	}
}

type mStorageMockFind struct {
	mock               *StorageMock
	defaultExpectation *StorageMockFindExpectation
	expectations       []*StorageMockFindExpectation

	callArgs []*StorageMockFindParams
	mutex    sync.RWMutex
}

// StorageMockFindExpectation specifies expectation struct of the Storage.Find
type StorageMockFindExpectation struct {
	mock    *StorageMock
	params  *StorageMockFindParams
	results *StorageMockFindResults
	Counter uint64
}

// StorageMockFindParams contains parameters of the Storage.Find
type StorageMockFindParams struct {
	key string
}

// StorageMockFindResults contains results of the Storage.Find
type StorageMockFindResults struct {
	p1  cli.PVZ
	err error
}

// Expect sets up expected params for Storage.Find
func (mmFind *mStorageMockFind) Expect(key string) *mStorageMockFind {
	if mmFind.mock.funcFind != nil {
		mmFind.mock.t.Fatalf("StorageMock.Find mock is already set by Set")
	}

	if mmFind.defaultExpectation == nil {
		mmFind.defaultExpectation = &StorageMockFindExpectation{}
	}

	mmFind.defaultExpectation.params = &StorageMockFindParams{key}
	for _, e := range mmFind.expectations {
		if minimock.Equal(e.params, mmFind.defaultExpectation.params) {
			mmFind.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFind.defaultExpectation.params)
		}
	}

	return mmFind
}

// Inspect accepts an inspector function that has same arguments as the Storage.Find
func (mmFind *mStorageMockFind) Inspect(f func(key string)) *mStorageMockFind {
	if mmFind.mock.inspectFuncFind != nil {
		mmFind.mock.t.Fatalf("Inspect function is already set for StorageMock.Find")
	}

	mmFind.mock.inspectFuncFind = f

	return mmFind
}

// Return sets up results that will be returned by Storage.Find
func (mmFind *mStorageMockFind) Return(p1 cli.PVZ, err error) *StorageMock {
	if mmFind.mock.funcFind != nil {
		mmFind.mock.t.Fatalf("StorageMock.Find mock is already set by Set")
	}

	if mmFind.defaultExpectation == nil {
		mmFind.defaultExpectation = &StorageMockFindExpectation{mock: mmFind.mock}
	}
	mmFind.defaultExpectation.results = &StorageMockFindResults{p1, err}
	return mmFind.mock
}

// Set uses given function f to mock the Storage.Find method
func (mmFind *mStorageMockFind) Set(f func(key string) (p1 cli.PVZ, err error)) *StorageMock {
	if mmFind.defaultExpectation != nil {
		mmFind.mock.t.Fatalf("Default expectation is already set for the Storage.Find method")
	}

	if len(mmFind.expectations) > 0 {
		mmFind.mock.t.Fatalf("Some expectations are already set for the Storage.Find method")
	}

	mmFind.mock.funcFind = f
	return mmFind.mock
}

// When sets expectation for the Storage.Find which will trigger the result defined by the following
// Then helper
func (mmFind *mStorageMockFind) When(key string) *StorageMockFindExpectation {
	if mmFind.mock.funcFind != nil {
		mmFind.mock.t.Fatalf("StorageMock.Find mock is already set by Set")
	}

	expectation := &StorageMockFindExpectation{
		mock:   mmFind.mock,
		params: &StorageMockFindParams{key},
	}
	mmFind.expectations = append(mmFind.expectations, expectation)
	return expectation
}

// Then sets up Storage.Find return parameters for the expectation previously defined by the When method
func (e *StorageMockFindExpectation) Then(p1 cli.PVZ, err error) *StorageMock {
	e.results = &StorageMockFindResults{p1, err}
	return e.mock
}

// Find implements pvz.Storage
func (mmFind *StorageMock) Find(key string) (p1 cli.PVZ, err error) {
	mm_atomic.AddUint64(&mmFind.beforeFindCounter, 1)
	defer mm_atomic.AddUint64(&mmFind.afterFindCounter, 1)

	if mmFind.inspectFuncFind != nil {
		mmFind.inspectFuncFind(key)
	}

	mm_params := StorageMockFindParams{key}

	// Record call args
	mmFind.FindMock.mutex.Lock()
	mmFind.FindMock.callArgs = append(mmFind.FindMock.callArgs, &mm_params)
	mmFind.FindMock.mutex.Unlock()

	for _, e := range mmFind.FindMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmFind.FindMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFind.FindMock.defaultExpectation.Counter, 1)
		mm_want := mmFind.FindMock.defaultExpectation.params
		mm_got := StorageMockFindParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFind.t.Errorf("StorageMock.Find got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFind.FindMock.defaultExpectation.results
		if mm_results == nil {
			mmFind.t.Fatal("No results are set for the StorageMock.Find")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmFind.funcFind != nil {
		return mmFind.funcFind(key)
	}
	mmFind.t.Fatalf("Unexpected call to StorageMock.Find. %v", key)
	return
}

// FindAfterCounter returns a count of finished StorageMock.Find invocations
func (mmFind *StorageMock) FindAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFind.afterFindCounter)
}

// FindBeforeCounter returns a count of StorageMock.Find invocations
func (mmFind *StorageMock) FindBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFind.beforeFindCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Find.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFind *mStorageMockFind) Calls() []*StorageMockFindParams {
	mmFind.mutex.RLock()

	argCopy := make([]*StorageMockFindParams, len(mmFind.callArgs))
	copy(argCopy, mmFind.callArgs)

	mmFind.mutex.RUnlock()

	return argCopy
}

// MinimockFindDone returns true if the count of the Find invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockFindDone() bool {
	for _, e := range m.FindMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFind != nil && mm_atomic.LoadUint64(&m.afterFindCounter) < 1 {
		return false
	}
	return true
}

// MinimockFindInspect logs each unmet expectation
func (m *StorageMock) MinimockFindInspect() {
	for _, e := range m.FindMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Find with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindCounter) < 1 {
		if m.FindMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.Find")
		} else {
			m.t.Errorf("Expected call to StorageMock.Find with params: %#v", *m.FindMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFind != nil && mm_atomic.LoadUint64(&m.afterFindCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Find")
	}
}

type mStorageMockReadAll struct {
	mock               *StorageMock
	defaultExpectation *StorageMockReadAllExpectation
	expectations       []*StorageMockReadAllExpectation
}

// StorageMockReadAllExpectation specifies expectation struct of the Storage.ReadAll
type StorageMockReadAllExpectation struct {
	mock *StorageMock

	results *StorageMockReadAllResults
	Counter uint64
}

// StorageMockReadAllResults contains results of the Storage.ReadAll
type StorageMockReadAllResults struct {
	err error
}

// Expect sets up expected params for Storage.ReadAll
func (mmReadAll *mStorageMockReadAll) Expect() *mStorageMockReadAll {
	if mmReadAll.mock.funcReadAll != nil {
		mmReadAll.mock.t.Fatalf("StorageMock.ReadAll mock is already set by Set")
	}

	if mmReadAll.defaultExpectation == nil {
		mmReadAll.defaultExpectation = &StorageMockReadAllExpectation{}
	}

	return mmReadAll
}

// Inspect accepts an inspector function that has same arguments as the Storage.ReadAll
func (mmReadAll *mStorageMockReadAll) Inspect(f func()) *mStorageMockReadAll {
	if mmReadAll.mock.inspectFuncReadAll != nil {
		mmReadAll.mock.t.Fatalf("Inspect function is already set for StorageMock.ReadAll")
	}

	mmReadAll.mock.inspectFuncReadAll = f

	return mmReadAll
}

// Return sets up results that will be returned by Storage.ReadAll
func (mmReadAll *mStorageMockReadAll) Return(err error) *StorageMock {
	if mmReadAll.mock.funcReadAll != nil {
		mmReadAll.mock.t.Fatalf("StorageMock.ReadAll mock is already set by Set")
	}

	if mmReadAll.defaultExpectation == nil {
		mmReadAll.defaultExpectation = &StorageMockReadAllExpectation{mock: mmReadAll.mock}
	}
	mmReadAll.defaultExpectation.results = &StorageMockReadAllResults{err}
	return mmReadAll.mock
}

// Set uses given function f to mock the Storage.ReadAll method
func (mmReadAll *mStorageMockReadAll) Set(f func() (err error)) *StorageMock {
	if mmReadAll.defaultExpectation != nil {
		mmReadAll.mock.t.Fatalf("Default expectation is already set for the Storage.ReadAll method")
	}

	if len(mmReadAll.expectations) > 0 {
		mmReadAll.mock.t.Fatalf("Some expectations are already set for the Storage.ReadAll method")
	}

	mmReadAll.mock.funcReadAll = f
	return mmReadAll.mock
}

// ReadAll implements pvz.Storage
func (mmReadAll *StorageMock) ReadAll() (err error) {
	mm_atomic.AddUint64(&mmReadAll.beforeReadAllCounter, 1)
	defer mm_atomic.AddUint64(&mmReadAll.afterReadAllCounter, 1)

	if mmReadAll.inspectFuncReadAll != nil {
		mmReadAll.inspectFuncReadAll()
	}

	if mmReadAll.ReadAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadAll.ReadAllMock.defaultExpectation.Counter, 1)

		mm_results := mmReadAll.ReadAllMock.defaultExpectation.results
		if mm_results == nil {
			mmReadAll.t.Fatal("No results are set for the StorageMock.ReadAll")
		}
		return (*mm_results).err
	}
	if mmReadAll.funcReadAll != nil {
		return mmReadAll.funcReadAll()
	}
	mmReadAll.t.Fatalf("Unexpected call to StorageMock.ReadAll.")
	return
}

// ReadAllAfterCounter returns a count of finished StorageMock.ReadAll invocations
func (mmReadAll *StorageMock) ReadAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadAll.afterReadAllCounter)
}

// ReadAllBeforeCounter returns a count of StorageMock.ReadAll invocations
func (mmReadAll *StorageMock) ReadAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadAll.beforeReadAllCounter)
}

// MinimockReadAllDone returns true if the count of the ReadAll invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockReadAllDone() bool {
	for _, e := range m.ReadAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadAll != nil && mm_atomic.LoadUint64(&m.afterReadAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadAllInspect logs each unmet expectation
func (m *StorageMock) MinimockReadAllInspect() {
	for _, e := range m.ReadAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.ReadAll")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadAllCounter) < 1 {
		m.t.Error("Expected call to StorageMock.ReadAll")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadAll != nil && mm_atomic.LoadUint64(&m.afterReadAllCounter) < 1 {
		m.t.Error("Expected call to StorageMock.ReadAll")
	}
}

type mStorageMockSave struct {
	mock               *StorageMock
	defaultExpectation *StorageMockSaveExpectation
	expectations       []*StorageMockSaveExpectation
}

// StorageMockSaveExpectation specifies expectation struct of the Storage.Save
type StorageMockSaveExpectation struct {
	mock *StorageMock

	results *StorageMockSaveResults
	Counter uint64
}

// StorageMockSaveResults contains results of the Storage.Save
type StorageMockSaveResults struct {
	err error
}

// Expect sets up expected params for Storage.Save
func (mmSave *mStorageMockSave) Expect() *mStorageMockSave {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("StorageMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &StorageMockSaveExpectation{}
	}

	return mmSave
}

// Inspect accepts an inspector function that has same arguments as the Storage.Save
func (mmSave *mStorageMockSave) Inspect(f func()) *mStorageMockSave {
	if mmSave.mock.inspectFuncSave != nil {
		mmSave.mock.t.Fatalf("Inspect function is already set for StorageMock.Save")
	}

	mmSave.mock.inspectFuncSave = f

	return mmSave
}

// Return sets up results that will be returned by Storage.Save
func (mmSave *mStorageMockSave) Return(err error) *StorageMock {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("StorageMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &StorageMockSaveExpectation{mock: mmSave.mock}
	}
	mmSave.defaultExpectation.results = &StorageMockSaveResults{err}
	return mmSave.mock
}

// Set uses given function f to mock the Storage.Save method
func (mmSave *mStorageMockSave) Set(f func() (err error)) *StorageMock {
	if mmSave.defaultExpectation != nil {
		mmSave.mock.t.Fatalf("Default expectation is already set for the Storage.Save method")
	}

	if len(mmSave.expectations) > 0 {
		mmSave.mock.t.Fatalf("Some expectations are already set for the Storage.Save method")
	}

	mmSave.mock.funcSave = f
	return mmSave.mock
}

// Save implements pvz.Storage
func (mmSave *StorageMock) Save() (err error) {
	mm_atomic.AddUint64(&mmSave.beforeSaveCounter, 1)
	defer mm_atomic.AddUint64(&mmSave.afterSaveCounter, 1)

	if mmSave.inspectFuncSave != nil {
		mmSave.inspectFuncSave()
	}

	if mmSave.SaveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSave.SaveMock.defaultExpectation.Counter, 1)

		mm_results := mmSave.SaveMock.defaultExpectation.results
		if mm_results == nil {
			mmSave.t.Fatal("No results are set for the StorageMock.Save")
		}
		return (*mm_results).err
	}
	if mmSave.funcSave != nil {
		return mmSave.funcSave()
	}
	mmSave.t.Fatalf("Unexpected call to StorageMock.Save.")
	return
}

// SaveAfterCounter returns a count of finished StorageMock.Save invocations
func (mmSave *StorageMock) SaveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSave.afterSaveCounter)
}

// SaveBeforeCounter returns a count of StorageMock.Save invocations
func (mmSave *StorageMock) SaveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSave.beforeSaveCounter)
}

// MinimockSaveDone returns true if the count of the Save invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSaveDone() bool {
	for _, e := range m.SaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSave != nil && mm_atomic.LoadUint64(&m.afterSaveCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveInspect logs each unmet expectation
func (m *StorageMock) MinimockSaveInspect() {
	for _, e := range m.SaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.Save")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Save")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSave != nil && mm_atomic.LoadUint64(&m.afterSaveCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Save")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockCreateInspect()

			m.MinimockFindInspect()

			m.MinimockReadAllInspect()

			m.MinimockSaveInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockCreateDone() &&
		m.MinimockFindDone() &&
		m.MinimockReadAllDone() &&
		m.MinimockSaveDone()
}
